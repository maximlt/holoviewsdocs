
<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>holoviews.core.dimension â€” HoloViews v1.14.7a1</title>
<link href="../../../_static/css/theme.css" rel="stylesheet"/>
<link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet"/>
<link href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet"/>
<link as="font" crossorigin="" href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link href="../../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/css/blank.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/togglebutton.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/mystnb.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/graphviz.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/copybutton.css" rel="stylesheet" type="text/css">
<link href="../../../_static/nbsite.css" rel="stylesheet" type="text/css">
<link href="../../../_static/css/custom.css" rel="stylesheet" type="text/css">
<link as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js" rel="preload">
<script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
<script src="../../../_static/jquery.js"></script>
<script src="../../../_static/underscore.js"></script>
<script src="../../../_static/doctools.js"></script>
<script src="../../../_static/togglebutton.js"></script>
<script src="../../../_static/clipboard.min.js"></script>
<script src="../../../_static/copybutton.js"></script>
<script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
<link href="../../../_static/favicon.ico" rel="shortcut icon"/>
<link href="../../../about.html" rel="author" title="About these documents">
<link href="../../../genindex.html" rel="index" title="Index">
<link href="../../../search.html" rel="search" title="Search"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="None" name="docsearch:language"/>
<!-- Google Analytics -->
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-61554933-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>
</link></link></link></link></link></link></head>
<body data-offset="80" data-spy="scroll" data-target="#bd-toc-nav">
<div class="container-fluid" id="banner"></div>
<nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">
<div id="navbar-start">
<a class="navbar-brand" href="../../../index.html">
<img alt="logo" class="logo" src="../../../_static/logo_horizontal.png"/>
</a>
</div>
<button aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbar-collapsible" data-toggle="collapse" type="button">
<span class="navbar-toggler-icon"></span>
</button>
<div class="col-lg-9 collapse navbar-collapse" id="navbar-collapsible">
<div class="mr-auto" id="navbar-center">
<div class="navbar-center-item">
<ul class="navbar-nav" id="navbar-main-elements">
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../index.html">
  Home
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../reference/index.html">
  Reference Gallery
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../releases.html">
  Releases
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../reference_manual/index.html">
  API
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../FAQ.html">
  FAQ
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../roadmap.html">
  Roadmap
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference external nav-link" href="https://github.com/holoviz/holoviews">
  Github source
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../about.html">
  About
 </a>
</li>
</ul>
</div>
</div>
<div id="navbar-end">
<div class="navbar-end-item">
<ul aria-label="Icon Links" class="navbar-nav" id="navbar-icon-links">
<li class="nav-item">
<a class="nav-link" href="https://github.com/holoviz/holoviews" rel="noopener" target="_blank" title="GitHub">
<span><i class="fab fa-github-square"></i></span>
<label class="sr-only">GitHub</label>
</a>
</li>
<li class="nav-item">
<a class="nav-link" href="https://twitter.com/holoviews" rel="noopener" target="_blank" title="Twitter">
<span><i class="fab fa-twitter-square"></i></span>
<label class="sr-only">Twitter</label>
</a>
</li>
<li class="nav-item">
<a class="nav-link" href="https://discourse.holoviz.org/" rel="noopener" target="_blank" title="Discourse">
<span><i class="fab fa-discourse"></i></span>
<label class="sr-only">Discourse</label>
</a>
</li>
</ul>
</div>
</div>
</div>
</div>
</nav>
<div class="container-xl">
<div class="row">
<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="col-12 col-md-3 bd-sidebar"><form action="../../../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="icon fas fa-search"></i>
<input aria-label="Search the docs ..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search the docs ..." type="search"/>
</form><nav aria-label="Main navigation" class="bd-links" id="bd-docs-nav">
<div class="bd-toc-item active">
</div>
</nav>
</div>
<div class="d-none d-xl-block col-xl-2 bd-toc">
</div>
<main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
<div>
<h1>Source code for holoviews.core.dimension</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">Provides Dimension objects for tracking the properties of a value,</span>
<span class="sd">axis or map dimension. Also supplies the Dimensioned abstract</span>
<span class="sd">baseclass for classes that accept Dimension values.</span>
<span class="sd">"""</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">param</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.accessors</span> <span class="kn">import</span> <span class="n">Opts</span><span class="p">,</span> <span class="n">Apply</span><span class="p">,</span> <span class="n">Redim</span>
<span class="kn">from</span> <span class="nn">.options</span> <span class="kn">import</span> <span class="n">Store</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">cleanup_custom_options</span>
<span class="kn">from</span> <span class="nn">.pprint</span> <span class="kn">import</span> <span class="n">PrettyPrinter</span>
<span class="kn">from</span> <span class="nn">.tree</span> <span class="kn">import</span> <span class="n">AttrTree</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">bytes_to_unicode</span>

<span class="c1"># Alias parameter support for pickle loading</span>

<span class="n">ALIASES</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'key_dimensions'</span><span class="p">:</span> <span class="s1">'kdims'</span><span class="p">,</span> <span class="s1">'value_dimensions'</span><span class="p">:</span> <span class="s1">'vdims'</span><span class="p">,</span>
           <span class="s1">'constant_dimensions'</span><span class="p">:</span> <span class="s1">'cdims'</span><span class="p">}</span>

<span class="n">title_format</span> <span class="o">=</span> <span class="s2">"</span><span class="si">{name}</span><span class="s2">: </span><span class="si">{val}{unit}</span><span class="s2">"</span>

<span class="n">redim</span> <span class="o">=</span> <span class="n">Redim</span> <span class="c1"># pickle compatibility - remove in 2.0</span>

<div class="viewcode-block" id="param_aliases"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.param_aliases">[docs]</a><span class="k">def</span> <span class="nf">param_aliases</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Called from __setstate__ in LabelledData in order to load</span>
<span class="sd">    old pickles with outdated parameter names.</span>

<span class="sd">    Warning: We want to keep pickle hacking to a minimum!</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">ALIASES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">old_param</span> <span class="o">=</span> <span class="s1">'_</span><span class="si">%s</span><span class="s1">_param_value'</span> <span class="o">%</span> <span class="n">old</span>
        <span class="n">new_param</span> <span class="o">=</span> <span class="s1">'_</span><span class="si">%s</span><span class="s1">_param_value'</span> <span class="o">%</span> <span class="n">new</span>
        <span class="k">if</span> <span class="n">old_param</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">new_param</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_param</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span></div>


<div class="viewcode-block" id="asdim"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.asdim">[docs]</a><span class="k">def</span> <span class="nf">asdim</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
    <span class="sd">"""Convert the input to a Dimension.</span>

<span class="sd">    Args:</span>
<span class="sd">        dimension: tuple, dict or string type to convert to Dimension</span>

<span class="sd">    Returns:</span>
<span class="sd">        A Dimension object constructed from the dimension spec. No</span>
<span class="sd">        copy is performed if the input is already a Dimension.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dimension</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">Dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1"> type could not be interpreted as Dimension. '</span>
                         <span class="s1">'Dimensions must be declared as a string, tuple, '</span>
                         <span class="s1">'dictionary or Dimension type.'</span><span class="p">)</span></div>

<div class="viewcode-block" id="dimension_name"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.dimension_name">[docs]</a><span class="k">def</span> <span class="nf">dimension_name</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
    <span class="sd">"""Return the Dimension.name for a dimension-like object.</span>

<span class="sd">    Args:</span>
<span class="sd">        dimension: Dimension or dimension string, tuple or dict</span>

<span class="sd">    Returns:</span>
<span class="sd">        The name of the Dimension or what would be the name if the</span>
<span class="sd">        input as converted to a Dimension.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dimension</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dimension</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dimension</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1"> type could not be interpreted as Dimension. '</span>
                         <span class="s1">'Dimensions must be declared as a string, tuple, '</span>
                         <span class="s1">'dictionary or Dimension type.'</span>
                         <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_dimensions"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.process_dimensions">[docs]</a><span class="k">def</span> <span class="nf">process_dimensions</span><span class="p">(</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="p">):</span>
    <span class="sd">"""Converts kdims and vdims to Dimension objects.</span>

<span class="sd">    Args:</span>
<span class="sd">        kdims: List or single key dimension(s) specified as strings,</span>
<span class="sd">            tuples dicts or Dimension objects.</span>
<span class="sd">        vdims: List or single value dimension(s) specified as strings,</span>
<span class="sd">            tuples dicts or Dimension objects.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary containing kdims and vdims converted to Dimension</span>
<span class="sd">        objects:</span>

<span class="sd">        {'kdims': [Dimension('x')], 'vdims': [Dimension('y')]</span>
<span class="sd">    """</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">'kdims'</span><span class="p">,</span> <span class="n">kdims</span><span class="p">),</span> <span class="p">(</span><span class="s1">'vdims'</span><span class="p">,</span> <span class="n">vdims</span><span class="p">)]:</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dims</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2"> argument expects a Dimension or list of dimensions, "</span>
                             <span class="s2">"specified as tuples, strings, dictionaries or Dimension "</span>
                             <span class="s2">"instances, not a </span><span class="si">%s</span><span class="s2"> type. Ensure you passed the data as the "</span>
                             <span class="s2">"first argument."</span> <span class="o">%</span> <span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Dimensions must be defined as a tuple, '</span>
                                 <span class="s1">'string, dictionary or Dimension instance, '</span>
                                 <span class="s1">'found a </span><span class="si">%s</span><span class="s1"> type.'</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">dimensions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">asdim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dimensions</span></div>



<div class="viewcode-block" id="Dimension"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimension">[docs]</a><span class="k">class</span> <span class="nc">Dimension</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Dimension objects are used to specify some important general</span>
<span class="sd">    features that may be associated with a collection of values.</span>

<span class="sd">    For instance, a Dimension may specify that a set of numeric values</span>
<span class="sd">    actually correspond to 'Height' (dimension name), in units of</span>
<span class="sd">    meters, with a descriptive label 'Height of adult males'.</span>

<span class="sd">    All dimensions object have a name that identifies them and a label</span>
<span class="sd">    containing a suitable description. If the label is not explicitly</span>
<span class="sd">    specified it matches the name.</span>

<span class="sd">    These two parameters define the core identity of the dimension</span>
<span class="sd">    object and must match if two dimension objects are to be considered</span>
<span class="sd">    equivalent. All other parameters are considered optional metadata</span>
<span class="sd">    and are not used when testing for equality.</span>

<span class="sd">    Unlike all the other parameters, these core parameters can be used</span>
<span class="sd">    to construct a Dimension object from a tuple. This format is</span>
<span class="sd">    sufficient to define an identical Dimension:</span>

<span class="sd">    Dimension('a', label='Dimension A') == Dimension(('a', 'Dimension A'))</span>

<span class="sd">    Everything else about a dimension is considered to reflect</span>
<span class="sd">    non-semantic preferences. Examples include the default value (which</span>
<span class="sd">    may be used in a visualization to set an initial slider position),</span>
<span class="sd">    how the value is to rendered as text (which may be used to specify</span>
<span class="sd">    the printed floating point precision) or a suitable range of values</span>
<span class="sd">    to consider for a particular analysis.</span>

<span class="sd">    Units</span>
<span class="sd">    -----</span>

<span class="sd">    Full unit support with automated conversions are on the HoloViews</span>
<span class="sd">    roadmap. Once rich unit objects are supported, the unit (or more</span>
<span class="sd">    specifically the type of unit) will be part of the core dimension</span>
<span class="sd">    specification used to establish equality.</span>

<span class="sd">    Until this feature is implemented, there are two auxiliary</span>
<span class="sd">    parameters that hold some partial information about the unit: the</span>
<span class="sd">    name of the unit and whether or not it is cyclic. The name of the</span>
<span class="sd">    unit is used as part of the pretty-printed representation and</span>
<span class="sd">    knowing whether it is cyclic is important for certain operations.</span>
<span class="sd">    """</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">       Short name associated with the Dimension, such as 'height' or</span>
<span class="s2">       'weight'. Valid Python identifiers make good names, because they</span>
<span class="s2">       can be used conveniently as a keyword in many contexts."""</span><span class="p">)</span>

    <span class="n">label</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Unrestricted label used to describe the dimension. A label</span>
<span class="s2">        should succinctly describe the dimension and may contain any</span>
<span class="s2">        characters, including Unicode and LaTeX expression."""</span><span class="p">)</span>

    <span class="n">cyclic</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Whether the range of this feature is cyclic such that the</span>
<span class="s2">        maximum allowed value (defined by the range parameter) is</span>
<span class="s2">        continuous with the minimum allowed value."""</span><span class="p">)</span>

    <span class="n">default</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Default value of the Dimension which may be useful for widget</span>
<span class="s2">        or other situations that require an initial or default value."""</span><span class="p">)</span>

    <span class="n">nodata</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Optional missing-data value for integer data.</span>
<span class="s2">        If non-None, data with this value will be replaced with NaN."""</span><span class="p">)</span>

    <span class="nb">range</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Tuple</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Specifies the minimum and maximum allowed values for a</span>
<span class="s2">        Dimension. None is used to represent an unlimited bound."""</span><span class="p">)</span>

    <span class="n">soft_range</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Tuple</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Specifies a minimum and maximum reference value, which</span>
<span class="s2">        may be overridden by the data."""</span><span class="p">)</span>

    <span class="n">step</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Optional floating point step specifying how frequently the</span>
<span class="s2">        underlying space should be sampled. May be used to define a</span>
<span class="s2">        discrete sampling over the range."""</span><span class="p">)</span>

    <span class="nb">type</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Optional type associated with the Dimension values. The type</span>
<span class="s2">        may be an inbuilt constructor (such as int, str, float) or a</span>
<span class="s2">        custom class object."""</span><span class="p">)</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Optional unit string associated with the Dimension. For</span>
<span class="s2">        instance, the string 'm' may be used represent units of meters</span>
<span class="s2">        and 's' to represent units of seconds."""</span><span class="p">)</span>

    <span class="n">value_format</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Callable</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Formatting function applied to each value before display."""</span><span class="p">)</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        Optional specification of the allowed value set for the</span>
<span class="s2">        dimension that may also be used to retain a categorical</span>
<span class="s2">        ordering."""</span><span class="p">)</span>

    <span class="c1"># Defines default formatting by type</span>
    <span class="n">type_formatters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">unit_format</span> <span class="o">=</span> <span class="s1">' (</span><span class="si">{unit}</span><span class="s1">)'</span>
    <span class="n">presets</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># A dictionary-like mapping name, (name,) or</span>
                 <span class="c1"># (name, unit) to a preset Dimension object</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Initializes the Dimension object with the given name.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="s1">'name'</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">'Dimension name must only be passed as the positional argument'</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">):</span>
            <span class="n">existing_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">())</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'unit'</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">presets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">preset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">presets</span><span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">'unit'</span><span class="p">]))]</span>
            <span class="n">existing_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">preset</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">existing_params</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="k">elif</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">presets</span><span class="p">:</span>
            <span class="n">existing_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">presets</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">())</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">spec</span><span class="p">,)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">presets</span><span class="p">:</span>
            <span class="n">existing_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">presets</span><span class="p">[(</span><span class="n">spec</span><span class="p">,)]</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">existing_params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">all_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">existing_params</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Dimensions specified as a tuple must be a tuple "</span>
                                 <span class="s2">"consisting of the name and label not: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">spec</span><span class="p">))</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="n">all_params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">all_params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
            <span class="k">if</span> <span class="s1">'label'</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="p">(</span><span class="n">label</span> <span class="o">!=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="o">!=</span> <span class="n">label</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s1">'Using label as supplied by keyword (</span><span class="si">{!r}</span><span class="s1">), ignoring '</span>
                        <span class="s1">'tuple value </span><span class="si">{!r}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">],</span> <span class="n">label</span><span class="p">))</span>
                <span class="n">all_params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">all_params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="n">all_params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">all_params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">''</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Dimension name cannot be the empty string'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">''</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Dimension label cannot be None or the empty string'</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'values'</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">values</span> <span class="o">==</span> <span class="s1">'initial'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">"The 'initial' string for dimension values "</span>
                               <span class="s2">"is no longer supported."</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">all_params</span><span class="p">[</span><span class="s1">'values'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">unique_array</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">all_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'</span><span class="si">%r</span><span class="s1"> default </span><span class="si">%s</span><span class="s1"> not found in declared values: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span>
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'</span><span class="si">%r</span><span class="s1"> default </span><span class="si">%s</span><span class="s1"> not in declared range: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">""""Returns the Dimensions tuple specification</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: Dimension tuple specification</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

<div class="viewcode-block" id="Dimension.clone"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimension.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">):</span>
        <span class="sd">"""Clones the Dimension with new parameters</span>

<span class="sd">        Derive a new Dimension that inherits existing parameters</span>
<span class="sd">        except for the supplied, explicit overrides</span>

<span class="sd">        Args:</span>
<span class="sd">            spec (tuple, optional): Dimension tuple specification</span>
<span class="sd">            **overrides: Dimension parameter overrides</span>

<span class="sd">        Returns:</span>
<span class="sd">            Cloned Dimension object</span>
<span class="sd">        """</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">(),</span> <span class="o">**</span><span class="n">overrides</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">overrides</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">'label'</span> <span class="ow">in</span> <span class="n">overrides</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">overrides</span><span class="p">[</span><span class="s1">'label'</span><span class="p">])</span>
        <span class="k">elif</span> <span class="s1">'label'</span> <span class="ow">in</span> <span class="n">overrides</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">overrides</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="o">!=</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">'Using label as supplied by keyword (</span><span class="si">{!r}</span><span class="s1">), ignoring '</span>
                    <span class="s1">'tuple value </span><span class="si">{!r}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">overrides</span><span class="p">[</span><span class="s1">'label'</span><span class="p">],</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="n">overrides</span><span class="p">[</span><span class="s1">'label'</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">settings</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                       <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'name'</span><span class="p">,</span> <span class="s1">'label'</span><span class="p">]})</span></div>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Hashes object on Dimension spec, i.e. (name, label).</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compatibility for pickles before alias attribute was introduced.</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">'_label_param_value'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="s2">"Implements equals operator including sanitized comparison."</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">spec</span>

        <span class="c1"># For comparison to strings. Name may be sanitized.</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">dimension_sanitizer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="s2">"Implements not equal operator including sanitized comparison."</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="s2">"Dimensions are sorted alphanumerically by name"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pprint_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"The pretty-printed label string for the Dimension"</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="p">(</span><span class="s1">''</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_format</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">bytes_to_unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">+</span> <span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">(</span><span class="n">onlychanged</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">changed</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'name'</span><span class="p">,</span><span class="s1">'label'</span><span class="p">]]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">'Dimension(</span><span class="si">{spec}</span><span class="s1">)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="s1">'existing'</span><span class="p">)</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="n">changed</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span>
                <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">)</span> <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">precedence</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">precedence</span><span class="p">))</span>
        <span class="n">kws</span> <span class="o">=</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">changed</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordering</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">'name'</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">'Dimension(</span><span class="si">{spec}</span><span class="s1">, </span><span class="si">{kws}</span><span class="s1">)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">kws</span><span class="o">=</span><span class="n">kws</span><span class="p">)</span>


<div class="viewcode-block" id="Dimension.pprint_value"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimension.pprint_value">[docs]</a>    <span class="k">def</span> <span class="nf">pprint_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">print_unit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""Applies the applicable formatter to the value.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Dimension value to format</span>

<span class="sd">        Returns:</span>
<span class="sd">            Formatted dimension value</span>
<span class="sd">        """</span>
        <span class="n">own_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_format</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_format</span>
                     <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_formatters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">own_type</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">formatter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">formatter</span><span class="p">):</span>
                <span class="n">formatted_value</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formatter</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="p">)):</span>
                    <span class="n">formatted_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
                    <span class="n">formatted_value</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dt64_to_dt</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">"\{(\w+)\}"</span><span class="p">,</span> <span class="n">formatter</span><span class="p">):</span>
                    <span class="n">formatted_value</span> <span class="o">=</span> <span class="n">formatter</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">formatted_value</span> <span class="o">=</span> <span class="n">formatter</span> <span class="o">%</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">formatted_value</span> <span class="o">=</span> <span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">print_unit</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">formatted_value</span> <span class="o">=</span> <span class="n">formatted_value</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="n">bytes_to_unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">formatted_value</span></div>

<div class="viewcode-block" id="Dimension.pprint_value_string"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimension.pprint_value_string">[docs]</a>    <span class="k">def</span> <span class="nf">pprint_value_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""Pretty print the dimension value and unit with title_format</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Dimension value to format</span>

<span class="sd">        Returns:</span>
<span class="sd">            Formatted dimension value string with unit</span>
<span class="sd">        """</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="s1">''</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">' '</span> <span class="o">+</span> <span class="n">bytes_to_unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">title_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">),</span> <span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LabelledData"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.LabelledData">[docs]</a><span class="k">class</span> <span class="nc">LabelledData</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    LabelledData is a mix-in class designed to introduce the group and</span>
<span class="sd">    label parameters (and corresponding methods) to any class</span>
<span class="sd">    containing data. This class assumes that the core data contents</span>
<span class="sd">    will be held in the attribute called 'data'.</span>

<span class="sd">    Used together, group and label are designed to allow a simple and</span>
<span class="sd">    flexible means of addressing data. For instance, if you are</span>
<span class="sd">    collecting the heights of people in different demographics, you</span>
<span class="sd">    could specify the values of your objects as 'Height' and then use</span>
<span class="sd">    the label to specify the (sub)population.</span>

<span class="sd">    In this scheme, one object may have the parameters set to</span>
<span class="sd">    [group='Height', label='Children'] and another may use</span>
<span class="sd">    [group='Height', label='Adults'].</span>

<span class="sd">    Note: Another level of specification is implicit in the type (i.e</span>
<span class="sd">    class) of the LabelledData object. A full specification of a</span>
<span class="sd">    LabelledData object is therefore given by the tuple</span>
<span class="sd">    (&lt;type&gt;, &lt;group&gt;, label&gt;). This additional level of specification is</span>
<span class="sd">    used in the traverse method.</span>

<span class="sd">    Any strings can be used for the group and label, but it can be</span>
<span class="sd">    convenient to use a capitalized string of alphanumeric characters,</span>
<span class="sd">    in which case the keys used for matching in the matches and</span>
<span class="sd">    traverse method will correspond exactly to {type}.{group}.{label}.</span>
<span class="sd">    Otherwise the strings provided will be sanitized to be valid</span>
<span class="sd">    capitalized Python identifiers, which works fine but can sometimes</span>
<span class="sd">    be confusing.</span>
<span class="sd">    """</span>

    <span class="n">group</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">'LabelledData'</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">       A string describing the type of data contained by the object.</span>
<span class="s2">       By default this will typically mirror the class name."""</span><span class="p">)</span>

    <span class="n">label</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">''</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">       Optional label describing the data, typically reflecting where</span>
<span class="s2">       or how it was measured. The label should allow a specific</span>
<span class="s2">       measurement or dataset to be referenced for a given group."""</span><span class="p">)</span>

    <span class="n">_deep_indexable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        All LabelledData subclasses must supply data to the</span>
<span class="sd">        constructor, which will be held on the .data attribute.</span>
<span class="sd">        This class also has an id instance attribute, which</span>
<span class="sd">        may be set to associate some custom options with the object.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_id</span> <span class="o">=</span> <span class="n">plot_id</span> <span class="ow">or</span> <span class="n">util</span><span class="o">.</span><span class="n">builtins</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">long_name</span><span class="p">)</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span>
            <span class="n">util</span><span class="o">.</span><span class="n">label_sanitizer</span><span class="o">.</span><span class="n">add_aliases</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">alias</span><span class="p">:</span><span class="n">long_name</span><span class="p">})</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">'label'</span><span class="p">]</span> <span class="o">=</span> <span class="n">long_name</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'group'</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">long_name</span><span class="p">)</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'group'</span><span class="p">]</span>
            <span class="n">util</span><span class="o">.</span><span class="n">group_sanitizer</span><span class="o">.</span><span class="n">add_aliases</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">alias</span><span class="p">:</span><span class="n">long_name</span><span class="p">})</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">'group'</span><span class="p">]</span> <span class="o">=</span> <span class="n">long_name</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">util</span><span class="o">.</span><span class="n">group_sanitizer</span><span class="o">.</span><span class="n">allowable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Supplied group </span><span class="si">%r</span><span class="s2"> contains invalid characters."</span> <span class="o">%</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">util</span><span class="o">.</span><span class="n">label_sanitizer</span><span class="o">.</span><span class="n">allowable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Supplied label </span><span class="si">%r</span><span class="s2"> contains invalid characters."</span> <span class="o">%</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>

    <span class="nd">@id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opts_id</span><span class="p">):</span>
        <span class="sd">"""Handles tracking and cleanup of custom ids."""</span>
        <span class="n">old_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="n">opts_id</span>
        <span class="k">if</span> <span class="n">old_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cleanup_custom_options</span><span class="p">(</span><span class="n">old_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opts_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">opts_id</span> <span class="o">!=</span> <span class="n">old_id</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opts_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Store</span><span class="o">.</span><span class="n">_weakrefs</span><span class="p">:</span>
                <span class="n">Store</span><span class="o">.</span><span class="n">_weakrefs</span><span class="p">[</span><span class="n">opts_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">cleanup_custom_options</span><span class="p">,</span> <span class="n">opts_id</span><span class="p">))</span>
            <span class="n">Store</span><span class="o">.</span><span class="n">_weakrefs</span><span class="p">[</span><span class="n">opts_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>


<div class="viewcode-block" id="LabelledData.clone"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.LabelledData.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shared_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">):</span>
        <span class="sd">"""Clones the object, overriding data and parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: New data replacing the existing data</span>
<span class="sd">            shared_data (bool, optional): Whether to use existing data</span>
<span class="sd">            new_type (optional): Type to cast object to</span>
<span class="sd">            link (bool, optional): Whether clone should be linked</span>
<span class="sd">                Determines whether Streams and Links attached to</span>
<span class="sd">                original object will be inherited.</span>
<span class="sd">            *args: Additional arguments to pass to constructor</span>
<span class="sd">            **overrides: New keyword arguments to pass to constructor</span>

<span class="sd">        Returns:</span>
<span class="sd">            Cloned object</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">new_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clone_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clone_type</span> <span class="o">=</span> <span class="n">new_type</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="n">new_type</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="s1">'existing'</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                      <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_params</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'group'</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="s1">'existing'</span><span class="p">)[</span><span class="s1">'group'</span><span class="p">]</span><span class="o">.</span><span class="n">default</span><span class="p">:</span>
                <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'group'</span><span class="p">)</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">'id'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shared_data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="k">if</span> <span class="n">link</span><span class="p">:</span>
                <span class="n">settings</span><span class="p">[</span><span class="s1">'plot_id'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_id</span>
        <span class="c1"># Apply name mangling for __ attribute</span>
        <span class="n">pos_args</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_'</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">'__pos_params'</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="n">clone_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">settings</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                          <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pos_args</span><span class="p">})</span></div>


<div class="viewcode-block" id="LabelledData.relabel"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.LabelledData.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">"""Clone object and apply new group and/or label.</span>

<span class="sd">        Applies relabeling to children up to the supplied depth.</span>

<span class="sd">        Args:</span>
<span class="sd">            label (str, optional): New label to apply to returned object</span>
<span class="sd">            group (str, optional): New group to apply to returned object</span>
<span class="sd">            depth (int, optional): Depth to which relabel will be applied</span>
<span class="sd">                If applied to container allows applying relabeling to</span>
<span class="sd">                contained objects up to the specified depth</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns relabelled object</span>
<span class="sd">        """</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_deep_indexable'</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">relabelled</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">relabelled</span><span class="p">))</span>
        <span class="n">keywords</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'label'</span><span class="p">,</span> <span class="n">label</span><span class="p">),</span> <span class="p">(</span><span class="s1">'group'</span><span class="p">,</span> <span class="n">group</span><span class="p">)]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">keywords</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="LabelledData.matches"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.LabelledData.matches">[docs]</a>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="sd">"""Whether the spec applies to this object.</span>

<span class="sd">        Args:</span>
<span class="sd">            spec: A function, spec or type to check for a match</span>
<span class="sd">                * A 'type[[.group].label]' string which is compared</span>
<span class="sd">                  against the type, group and label of this object</span>
<span class="sd">                * A function which is given the object and returns</span>
<span class="sd">                  a boolean.</span>
<span class="sd">                * An object type matched using isinstance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: Whether the spec matched this object.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span> <span class="k">return</span> <span class="n">spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span> <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
        <span class="n">specification</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="n">split_spec</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'.'</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">spec</span>
        <span class="n">split_spec</span><span class="p">,</span> <span class="n">nocompare</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">'*'</span> <span class="ow">or</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">split_spec</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">nocompare</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="n">match_fn</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nocompare</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">nc</span><span class="p">))</span>
        <span class="n">self_spec</span> <span class="o">=</span> <span class="n">match_fn</span><span class="p">(</span><span class="n">split_spec</span><span class="p">)</span>
        <span class="n">unescaped_match</span> <span class="o">=</span> <span class="n">match_fn</span><span class="p">(</span><span class="n">specification</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">split_spec</span><span class="p">)])</span> <span class="o">==</span> <span class="n">self_spec</span>
        <span class="k">if</span> <span class="n">unescaped_match</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="n">sanitizers</span> <span class="o">=</span> <span class="p">[</span><span class="n">util</span><span class="o">.</span><span class="n">sanitize_identifier</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">group_sanitizer</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">label_sanitizer</span><span class="p">]</span>
        <span class="n">identifier_specification</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                         <span class="k">for</span> <span class="n">ident</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specification</span><span class="p">,</span> <span class="n">sanitizers</span><span class="p">))</span>
        <span class="n">identifier_match</span> <span class="o">=</span> <span class="n">match_fn</span><span class="p">(</span><span class="n">identifier_specification</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">split_spec</span><span class="p">)])</span> <span class="o">==</span> <span class="n">self_spec</span>
        <span class="k">return</span> <span class="n">identifier_match</span></div>

<div class="viewcode-block" id="LabelledData.traverse"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.LabelledData.traverse">[docs]</a>    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">specs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_breadth</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Traverses object returning matching items</span>
<span class="sd">        Traverses the set of children of the object, collecting the</span>
<span class="sd">        all objects matching the defined specs. Each object can be</span>
<span class="sd">        processed with the supplied function.</span>
<span class="sd">        Args:</span>
<span class="sd">            fn (function, optional): Function applied to matched objects</span>
<span class="sd">            specs: List of specs to match</span>
<span class="sd">                Specs must be types, functions or type[.group][.label]</span>
<span class="sd">                specs to select objects to return, by default applies</span>
<span class="sd">                to all objects.</span>
<span class="sd">            full_breadth: Whether to traverse all objects</span>
<span class="sd">                Whether to traverse the full set of objects on each</span>
<span class="sd">                container or only the first.</span>
<span class="sd">        Returns:</span>
<span class="sd">            list: List of objects that matched</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">specs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">specs</span><span class="p">]</span>
        <span class="n">accumulator</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">specs</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">matches</span><span class="p">:</span> <span class="k">break</span>
        <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">accumulator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># Assumes composite objects are iterables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deep_indexable</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">el</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">accumulator</span> <span class="o">+=</span> <span class="n">el</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">full_breadth</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">full_breadth</span><span class="p">:</span> <span class="k">break</span>
        <span class="k">return</span> <span class="n">accumulator</span></div>


<div class="viewcode-block" id="LabelledData.map"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.LabelledData.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_fn</span><span class="p">,</span> <span class="n">specs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Map a function to all objects matching the specs</span>

<span class="sd">        Recursively replaces elements using a map function when the</span>
<span class="sd">        specs apply, by default applies to all objects, e.g. to apply</span>
<span class="sd">        the function to all contained Curve objects:</span>

<span class="sd">            dmap.map(fn, hv.Curve)</span>

<span class="sd">        Args:</span>
<span class="sd">            map_fn: Function to apply to each object</span>
<span class="sd">            specs: List of specs to match</span>
<span class="sd">                List of types, functions or type[.group][.label] specs</span>
<span class="sd">                to select objects to return, by default applies to all</span>
<span class="sd">                objects.</span>
<span class="sd">            clone: Whether to clone the object or transform inplace</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns the object after the map_fn has been applied</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">specs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">specs</span><span class="p">]</span>
        <span class="n">applies</span> <span class="o">=</span> <span class="n">specs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deep_indexable</span><span class="p">:</span>
            <span class="n">deep_mapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">shared_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">clone</span> <span class="k">else</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_val</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">map_fn</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">clone</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">deep_mapped</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
            <span class="k">if</span> <span class="n">applies</span><span class="p">:</span> <span class="n">deep_mapped</span> <span class="o">=</span> <span class="n">map_fn</span><span class="p">(</span><span class="n">deep_mapped</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">deep_mapped</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">map_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">applies</span> <span class="k">else</span> <span class="bp">self</span></div>


    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"Ensures pickles save options applied to this objects."</span>
        <span class="n">obj_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Store</span><span class="o">.</span><span class="n">save_option_state</span> <span class="ow">and</span> <span class="p">(</span><span class="n">obj_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'_id'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">custom_key</span> <span class="o">=</span> <span class="s1">'_custom_option_</span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">obj_dict</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">custom_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj_dict</span><span class="p">:</span>
                    <span class="n">obj_dict</span><span class="p">[</span><span class="n">custom_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">backend</span><span class="p">:</span><span class="n">s</span><span class="p">[</span><span class="n">obj_dict</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]]</span>
                                            <span class="k">for</span> <span class="n">backend</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="n">Store</span><span class="o">.</span><span class="n">_custom_options</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                            <span class="k">if</span> <span class="n">obj_dict</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]</span> <span class="ow">in</span> <span class="n">s</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj_dict</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">"Could not pickle custom style information."</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj_dict</span>


    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="s2">"Restores options applied to this object."</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">param_aliases</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># Backwards compatibility for objects before id was made a property</span>
        <span class="n">opts_id</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]</span> <span class="k">if</span> <span class="s1">'_id'</span> <span class="ow">in</span> <span class="n">d</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'id'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">load_options</span> <span class="o">=</span> <span class="n">Store</span><span class="o">.</span><span class="n">load_counter_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">load_options</span><span class="p">:</span>
                <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'_custom_option'</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                    <span class="n">custom_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'_'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="n">Store</span><span class="o">.</span><span class="n">load_counter_offset</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">match</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="c1"># Backward compatibility before multiple backends</span>
                        <span class="n">backend_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'matplotlib'</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">match</span><span class="p">]}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">backend_info</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">match</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">backend</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span>  <span class="n">backend_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">backend</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Store</span><span class="o">.</span><span class="n">_custom_options</span><span class="p">:</span>
                            <span class="n">Store</span><span class="o">.</span><span class="n">_custom_options</span><span class="p">[</span><span class="n">backend</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="n">Store</span><span class="o">.</span><span class="n">_custom_options</span><span class="p">[</span><span class="n">backend</span><span class="p">][</span><span class="n">custom_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span>
                    <span class="k">if</span> <span class="n">backend_info</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">custom_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Store</span><span class="o">.</span><span class="n">_weakrefs</span><span class="p">:</span>
                            <span class="n">Store</span><span class="o">.</span><span class="n">_weakrefs</span><span class="p">[</span><span class="n">custom_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">cleanup_custom_options</span><span class="p">,</span> <span class="n">custom_id</span><span class="p">))</span>
                        <span class="n">Store</span><span class="o">.</span><span class="n">_weakrefs</span><span class="p">[</span><span class="n">opts_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">opts_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">opts_id</span> <span class="o">+=</span> <span class="n">Store</span><span class="o">.</span><span class="n">load_counter_offset</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">"Could not unpickle custom style information."</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]</span> <span class="o">=</span> <span class="n">opts_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">({})</span></div>


<div class="viewcode-block" id="Dimensioned"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned">[docs]</a><span class="k">class</span> <span class="nc">Dimensioned</span><span class="p">(</span><span class="n">LabelledData</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Dimensioned is a base class that allows the data contents of a</span>
<span class="sd">    class to be associated with dimensions. The contents associated</span>
<span class="sd">    with dimensions may be partitioned into one of three types</span>

<span class="sd">    * key dimensions: These are the dimensions that can be indexed via</span>
<span class="sd">                      the __getitem__ method. Dimension objects</span>
<span class="sd">                      supporting key dimensions must support indexing</span>
<span class="sd">                      over these dimensions and may also support</span>
<span class="sd">                      slicing. This list ordering of dimensions</span>
<span class="sd">                      describes the positional components of each</span>
<span class="sd">                      multi-dimensional indexing operation.</span>

<span class="sd">                      For instance, if the key dimension names are</span>
<span class="sd">                      'weight' followed by 'height' for Dimensioned</span>
<span class="sd">                      object 'obj', then obj[80,175] indexes a weight</span>
<span class="sd">                      of 80 and height of 175.</span>

<span class="sd">                      Accessed using either kdims.</span>

<span class="sd">    * value dimensions: These dimensions correspond to any data held</span>
<span class="sd">                        on the Dimensioned object not in the key</span>
<span class="sd">                        dimensions. Indexing by value dimension is</span>
<span class="sd">                        supported by dimension name (when there are</span>
<span class="sd">                        multiple possible value dimensions); no</span>
<span class="sd">                        slicing semantics is supported and all the</span>
<span class="sd">                        data associated with that dimension will be</span>
<span class="sd">                        returned at once. Note that it is not possible</span>
<span class="sd">                        to mix value dimensions and deep dimensions.</span>

<span class="sd">                        Accessed using either vdims.</span>

<span class="sd">    * deep dimensions: These are dynamically computed dimensions that</span>
<span class="sd">                       belong to other Dimensioned objects that are</span>
<span class="sd">                       nested in the data. Objects that support this</span>
<span class="sd">                       should enable the _deep_indexable flag. Note</span>
<span class="sd">                       that it is not possible to mix value dimensions</span>
<span class="sd">                       and deep dimensions.</span>

<span class="sd">                       Accessed using either ddims.</span>

<span class="sd">    Dimensioned class support generalized methods for finding the</span>
<span class="sd">    range and type of values along a particular Dimension. The range</span>
<span class="sd">    method relies on the appropriate implementation of the</span>
<span class="sd">    dimension_values methods on subclasses.</span>

<span class="sd">    The index of an arbitrary dimension is its positional index in the</span>
<span class="sd">    list of all dimensions, starting with the key dimensions, followed</span>
<span class="sd">    by the value dimensions and ending with the deep dimensions.</span>
<span class="sd">    """</span>

    <span class="n">cdims</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Dict</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">(),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">       The constant dimensions defined as a dictionary of Dimension:value</span>
<span class="s2">       pairs providing additional dimension information about the object.</span>

<span class="s2">       Aliased with constant_dimensions."""</span><span class="p">)</span>

    <span class="n">kdims</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">       The key dimensions defined as list of dimensions that may be</span>
<span class="s2">       used in indexing (and potential slicing) semantics. The order</span>
<span class="s2">       of the dimensions listed here determines the semantics of each</span>
<span class="s2">       component of a multi-dimensional indexing operation.</span>

<span class="s2">       Aliased with key_dimensions."""</span><span class="p">)</span>

    <span class="n">vdims</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">       The value dimensions defined as the list of dimensions used to</span>
<span class="s2">       describe the components of the data. If multiple value</span>
<span class="s2">       dimensions are supplied, a particular value dimension may be</span>
<span class="s2">       indexed by name after the key dimensions.</span>

<span class="s2">       Aliased with value_dimensions."""</span><span class="p">)</span>

    <span class="n">group</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">'Dimensioned'</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">       A string describing the data wrapped by the object."""</span><span class="p">)</span>

    <span class="n">__abstract</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_dim_groups</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'kdims'</span><span class="p">,</span> <span class="s1">'vdims'</span><span class="p">,</span> <span class="s1">'cdims'</span><span class="p">,</span> <span class="s1">'ddims'</span><span class="p">]</span>
    <span class="n">_dim_aliases</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">key_dimensions</span><span class="o">=</span><span class="s1">'kdims'</span><span class="p">,</span> <span class="n">value_dimensions</span><span class="o">=</span><span class="s1">'vdims'</span><span class="p">,</span>
                        <span class="n">constant_dimensions</span><span class="o">=</span><span class="s1">'cdims'</span><span class="p">,</span> <span class="n">deep_dimensions</span><span class="o">=</span><span class="s1">'ddims'</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">process_dimensions</span><span class="p">(</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">'cdims'</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">'cdims'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">)</span> <span class="k">else</span> <span class="n">Dimension</span><span class="p">(</span><span class="n">d</span><span class="p">):</span> <span class="n">val</span>
                               <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s1">'cdims'</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="p">)</span>
        <span class="n">cdims</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdims</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_constants</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">cdims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Instantiate accessors</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">opts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Opts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">redim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Redim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_valid_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="sd">"""Validates key dimension input</span>

<span class="sd">        Returns kdims if no dimensions are specified"""</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimensions</span><span class="p">]</span>

        <span class="n">valid_dimensions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">):</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Supplied dimensions </span><span class="si">%s</span><span class="s2"> not found."</span> <span class="o">%</span> <span class="n">dim</span><span class="p">)</span>
            <span class="n">valid_dimensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">valid_dimensions</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"The list of deep dimensions"</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deep_indexable</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>


<div class="viewcode-block" id="Dimensioned.dimensions"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned.dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="s1">'all'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""Lists the available dimensions on the object</span>

<span class="sd">        Provides convenient access to Dimensions on nested Dimensioned</span>
<span class="sd">        objects. Dimensions can be selected by their type, i.e. 'key'</span>
<span class="sd">        or 'value' dimensions. By default 'all' dimensions are</span>
<span class="sd">        returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            selection: Type of dimensions to return</span>
<span class="sd">                The type of dimension, i.e. one of 'key', 'value',</span>
<span class="sd">                'constant' or 'all'.</span>
<span class="sd">            label: Whether to return the name, label or Dimension</span>
<span class="sd">                Whether to return the Dimension objects (False),</span>
<span class="sd">                the Dimension names (True/'name') or labels ('label').</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of Dimension objects or their names or labels</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'name'</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">'short'</span>
        <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">'label'</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">'long'</span>
        <span class="k">elif</span> <span class="n">label</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"label needs to be one of True, False, 'name' or 'label'"</span><span class="p">)</span>

        <span class="n">lambdas</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'k'</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">kdims</span><span class="p">,</span> <span class="p">{</span><span class="s1">'full_breadth'</span><span class="p">:</span> <span class="kc">False</span><span class="p">}),</span>
                   <span class="s1">'v'</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">vdims</span><span class="p">,</span> <span class="p">{}),</span>
                   <span class="s1">'c'</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">cdims</span><span class="p">,</span> <span class="p">{})}</span>
        <span class="n">aliases</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'key'</span><span class="p">:</span> <span class="s1">'k'</span><span class="p">,</span> <span class="s1">'value'</span><span class="p">:</span> <span class="s1">'v'</span><span class="p">,</span> <span class="s1">'constant'</span><span class="p">:</span> <span class="s1">'c'</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">selection</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'all'</span><span class="p">,</span> <span class="s1">'ranges'</span><span class="p">]:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_groups</span> <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="s1">'cdims'</span><span class="p">]</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span>
                    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span>  <span class="p">[</span><span class="n">dim</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">selection</span>
                     <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">dims'</span> <span class="o">%</span> <span class="n">aliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">group</span><span class="p">))]</span>
        <span class="k">elif</span> <span class="n">aliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lambdas</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">aliases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">selection</span><span class="p">)</span>
            <span class="n">lmbd</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">lambdas</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>
            <span class="n">key_traversal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">lmbd</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span> <span class="k">for</span> <span class="n">keydims</span> <span class="ow">in</span> <span class="n">key_traversal</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">keydims</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">"Invalid selection </span><span class="si">%r</span><span class="s2">, valid selections include"</span>
                           <span class="s2">"'all', 'value' and 'key' dimensions"</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">selection</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">dim</span><span class="o">.</span><span class="n">label</span> <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">'long'</span> <span class="k">else</span> <span class="n">dim</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">label</span> <span class="k">else</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span></div>


<div class="viewcode-block" id="Dimensioned.get_dimension"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned.get_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">get_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""Get a Dimension object by name or index.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: Dimension to look up by name or integer index</span>
<span class="sd">            default (optional): Value returned if Dimension not found</span>
<span class="sd">            strict (bool, optional): Raise a KeyError if not found</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dimension object for the requested dimension or default</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'Dimension lookup supports int, string, '</span>
                            <span class="s1">'and Dimension instances, cannot lookup '</span>
                            <span class="s1">'Dimensions using </span><span class="si">%s</span><span class="s1"> type.'</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">all_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_dims</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">all_dims</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">"Dimension </span><span class="si">%r</span><span class="s2"> not found"</span> <span class="o">%</span> <span class="n">dimension</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">default</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">all_dims</span> <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">"</span><span class="si">%r</span><span class="s2"> not found."</span> <span class="o">%</span> <span class="n">dimension</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dims</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension_name</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
            <span class="n">name_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="o">.</span><span class="n">spec</span><span class="p">:</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">all_dims</span><span class="p">}</span>
            <span class="n">name_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">all_dims</span><span class="p">})</span>
            <span class="n">name_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">all_dims</span><span class="p">})</span>
            <span class="n">name_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">util</span><span class="o">.</span><span class="n">dimension_sanitizer</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">name</span><span class="p">):</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">all_dims</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="n">dimension</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name_map</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">"Dimension </span><span class="si">%r</span><span class="s2"> not found."</span> <span class="o">%</span> <span class="n">dimension</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dimensioned.get_dimension_index"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned.get_dimension_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_dimension_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
        <span class="sd">"""Get the index of the requested dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: Dimension to look up by name or by index</span>

<span class="sd">        Returns:</span>
<span class="sd">            Integer index of the requested dimension</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vdims</span><span class="p">))</span> <span class="ow">or</span>
                <span class="n">dimension</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">())):</span>
                <span class="k">return</span> <span class="n">dimension</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Dimension index out of bounds'</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">dimension_name</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">vdims</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Dimension </span><span class="si">%s</span><span class="s2"> not found in </span><span class="si">%s</span><span class="s2">."</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dimensioned.get_dimension_type"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned.get_dimension_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_dimension_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">"""Get the type of the requested dimension.</span>

<span class="sd">        Type is determined by Dimension.type attribute or common</span>
<span class="sd">        type of the dimension values, otherwise None.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: Dimension to look up by name or by index</span>

<span class="sd">        Returns:</span>
<span class="sd">            Declared type of values along the dimension</span>
<span class="sd">        """</span>
        <span class="n">dim_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_obj</span> <span class="ow">and</span> <span class="n">dim_obj</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dim_obj</span><span class="o">.</span><span class="n">type</span>
        <span class="n">dim_vals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_values</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dim_vals</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dim_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Multi-dimensional indexing semantics is determined by the list</span>
<span class="sd">        of key dimensions. For instance, the first indexing component</span>
<span class="sd">        will index the first key dimension.</span>

<span class="sd">        After the key dimensions are given, *either* a value dimension</span>
<span class="sd">        name may follow (if there are multiple value dimensions) *or*</span>
<span class="sd">        deep dimensions may then be listed (for applicable deep</span>
<span class="sd">        dimensions).</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span>


<div class="viewcode-block" id="Dimensioned.select"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection_specs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Applies selection by dimension name</span>

<span class="sd">        Applies a selection along the dimensions of the object using</span>
<span class="sd">        keyword arguments. The selection may be narrowed to certain</span>
<span class="sd">        objects using selection_specs. For container objects the</span>
<span class="sd">        selection will be applied to all children as well.</span>

<span class="sd">        Selections may select a specific value, slice or set of values:</span>

<span class="sd">        * value: Scalar values will select rows along with an exact</span>
<span class="sd">                 match, e.g.:</span>

<span class="sd">            ds.select(x=3)</span>

<span class="sd">        * slice: Slices may be declared as tuples of the upper and</span>
<span class="sd">                 lower bound, e.g.:</span>

<span class="sd">            ds.select(x=(0, 3))</span>

<span class="sd">        * values: A list of values may be selected using a list or</span>
<span class="sd">                  set, e.g.:</span>

<span class="sd">            ds.select(x=[0, 1, 2])</span>

<span class="sd">        Args:</span>
<span class="sd">            selection_specs: List of specs to match on</span>
<span class="sd">                A list of types, functions, or type[.group][.label]</span>
<span class="sd">                strings specifying which objects to apply the</span>
<span class="sd">                selection on.</span>
<span class="sd">            **selection: Dictionary declaring selections by dimension</span>
<span class="sd">                Selections can be scalar values, tuple ranges, lists</span>
<span class="sd">                of discrete values and boolean arrays</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns an Dimensioned object containing the selected data</span>
<span class="sd">            or a scalar if a single value was selected</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">selection_specs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection_specs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">selection_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">selection_specs</span><span class="p">]</span>

        <span class="c1"># Apply all indexes applying on this object</span>
        <span class="n">vdims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span><span class="o">+</span><span class="p">[</span><span class="s1">'value'</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">kdims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span>
        <span class="n">local_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kdims</span><span class="o">+</span><span class="n">vdims</span><span class="p">}</span>

        <span class="c1"># Check selection_spec applies</span>
        <span class="k">if</span> <span class="n">selection_specs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection_specs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">selection_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">selection_specs</span><span class="p">]</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">selection_specs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Apply selection to self</span>
        <span class="k">if</span> <span class="n">local_kwargs</span> <span class="ow">and</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">ndims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
                <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">vdims</span><span class="p">)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndims</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">local_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="s1">'value'</span><span class="p">:</span>
                    <span class="n">select</span> <span class="o">+=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">select</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deep_indexable</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">select</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">shared_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">select</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">Dimensioned</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">selection</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">Dimensioned</span><span class="p">):</span>
            <span class="c1"># Apply the selection on the selected object of a different type</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="s1">'value'</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">kw</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selection_specs</span><span class="o">=</span><span class="n">selection_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">Dimensioned</span><span class="p">)</span> <span class="ow">and</span> <span class="n">selection</span><span class="o">.</span><span class="n">_deep_indexable</span><span class="p">:</span>
            <span class="c1"># Apply the deep selection on each item in local selection</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">selection</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dimensions</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="s1">'value'</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">kw</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
                    <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selection_specs</span><span class="o">=</span><span class="n">selection_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">selection</span></div>


<div class="viewcode-block" id="Dimensioned.dimension_values"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned.dimension_values">[docs]</a>    <span class="k">def</span> <span class="nf">dimension_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Return the values along the requested dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: The dimension to return values for</span>
<span class="sd">            expanded (bool, optional): Whether to expand values</span>
<span class="sd">                Whether to return the expanded values, behavior depends</span>
<span class="sd">                on the type of data:</span>
<span class="sd">                  * Columnar: If false returns unique values</span>
<span class="sd">                  * Geometry: If false returns scalar values per geometry</span>
<span class="sd">                  * Gridded: If false returns 1D coordinates</span>
<span class="sd">            flat (bool, optional): Whether to flatten array</span>

<span class="sd">        Returns:</span>
<span class="sd">            NumPy array of values along the requested dimension</span>
<span class="sd">        """</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_constants</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Dimension </span><span class="si">%s</span><span class="s2"> not found in </span><span class="si">%s</span><span class="s2">."</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dimensioned.range"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned.range">[docs]</a>    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">data_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dimension_range</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Return the lower and upper bounds of values along dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: The dimension to compute the range on.</span>
<span class="sd">            data_range (bool): Compute range from data values</span>
<span class="sd">            dimension_range (bool): Include Dimension ranges</span>
<span class="sd">                Whether to include Dimension range and soft_range</span>
<span class="sd">                in range calculation</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple containing the lower and upper bound</span>
<span class="sd">        """</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">data_range</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dimension_range</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dimension</span><span class="o">.</span><span class="n">range</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dimension_range</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dimension</span><span class="o">.</span><span class="n">range</span>
        <span class="k">elif</span> <span class="n">data_range</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">vdims</span><span class="p">:</span>
                <span class="n">dim_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_values</span><span class="p">(</span><span class="n">dimension</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">find_range</span><span class="p">(</span><span class="n">dim_vals</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dname</span> <span class="o">=</span> <span class="n">dimension</span><span class="o">.</span><span class="n">name</span>
                <span class="n">match_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dname</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">kdims</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">vdims</span>
                <span class="n">range_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">dname</span><span class="p">)</span>
                <span class="n">ranges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">range_fn</span><span class="p">,</span> <span class="p">[</span><span class="n">match_fn</span><span class="p">])</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">max_range</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dimension_range</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">dimension_range</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">dimension</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">dimension</span><span class="o">.</span><span class="n">soft_range</span><span class="p">)</span></div>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PrettyPrinter</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PrettyPrinter</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Dimensioned.options"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.Dimensioned.options">[docs]</a>    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Applies simplified option definition returning a new object.</span>

<span class="sd">        Applies options on an object or nested group of objects in a</span>
<span class="sd">        flat format returning a new object with the options</span>
<span class="sd">        applied. If the options are to be set directly on the object a</span>
<span class="sd">        simple format may be used, e.g.:</span>

<span class="sd">            obj.options(cmap='viridis', show_title=False)</span>

<span class="sd">        If the object is nested the options must be qualified using</span>
<span class="sd">        a type[.group][.label] specification, e.g.:</span>

<span class="sd">            obj.options('Image', cmap='viridis', show_title=False)</span>

<span class="sd">        or using:</span>

<span class="sd">            obj.options({'Image': dict(cmap='viridis', show_title=False)})</span>

<span class="sd">        Identical to the .opts method but returns a clone of the object</span>
<span class="sd">        by default.</span>

<span class="sd">        Args:</span>
<span class="sd">            *args: Sets of options to apply to object</span>
<span class="sd">                Supports a number of formats including lists of Options</span>
<span class="sd">                objects, a type[.group][.label] followed by a set of</span>
<span class="sd">                keyword options to apply and a dictionary indexed by</span>
<span class="sd">                type[.group][.label] specs.</span>
<span class="sd">            backend (optional): Backend to apply options to</span>
<span class="sd">                Defaults to current selected backend</span>
<span class="sd">            clone (bool, optional): Whether to clone object</span>
<span class="sd">                Options can be applied inplace with clone=False</span>
<span class="sd">            **kwargs: Keywords of options</span>
<span class="sd">                Set of options to apply to the object</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns the cloned object with the options applied</span>
<span class="sd">        """</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'backend'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">args</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">options</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Please specify a list of option objects, or kwargs, but not both'</span><span class="p">)</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">args</span> <span class="ow">and</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">'backend'</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Options must be defined in one of two formats. "</span>
                             <span class="s2">"Either supply keywords defining the options for "</span>
                             <span class="s2">"the current object, e.g. obj.options(cmap='viridis'), "</span>
                             <span class="s2">"or explicitly define the type, e.g. "</span>
                             <span class="s2">"obj.options({'Image': {'cmap': 'viridis'}}). "</span>
                             <span class="s2">"Supplying both formats is not supported."</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">'Only a single dictionary can be passed '</span>
                                   <span class="s1">'as a positional argument. Only processing '</span>
                                   <span class="s1">'the first dictionary'</span><span class="p">)</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="n">Options</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span> <span class="k">for</span> <span class="n">spec</span><span class="p">,</span><span class="n">kws</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">elif</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="n">opts</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expanded_backends</span> <span class="o">=</span> <span class="p">[(</span><span class="n">backend</span><span class="p">,</span> <span class="p">{})]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="c1"># assuming a flat list of Options objects</span>
            <span class="n">expanded_backends</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">_expand_by_backend</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expanded_backends</span> <span class="o">=</span> <span class="p">[(</span><span class="n">backend</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">_expand_options</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">backend</span><span class="p">))]</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">backend</span><span class="p">,</span> <span class="n">expanded</span> <span class="ow">in</span> <span class="n">expanded_backends</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">opts</span><span class="o">.</span><span class="n">_dispatch_opts</span><span class="p">(</span><span class="n">expanded</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">clone</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

    <span class="k">def</span> <span class="nf">_repr_mimebundle_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Resolves the class hierarchy for the class rendering the</span>
<span class="sd">        object using any display hooks registered on Store.display</span>
<span class="sd">        hooks.  The output of all registered display_hooks is then</span>
<span class="sd">        combined and returned.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Store</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="ViewableElement"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.ViewableElement">[docs]</a><span class="k">class</span> <span class="nc">ViewableElement</span><span class="p">(</span><span class="n">Dimensioned</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A ViewableElement is a dimensioned datastructure that may be</span>
<span class="sd">    associated with a corresponding atomic visualization. An atomic</span>
<span class="sd">    visualization will display the data on a single set of axes</span>
<span class="sd">    (i.e. excludes multiple subplots that are displayed at once). The</span>
<span class="sd">    only new parameter introduced by ViewableElement is the title</span>
<span class="sd">    associated with the object for display.</span>
<span class="sd">    """</span>

    <span class="n">__abstract</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_auxiliary_component</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">group</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">'ViewableElement'</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="ViewableTree"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.ViewableTree">[docs]</a><span class="k">class</span> <span class="nc">ViewableTree</span><span class="p">(</span><span class="n">AttrTree</span><span class="p">,</span> <span class="n">Dimensioned</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A ViewableTree is an AttrTree with Viewable objects as its leaf</span>
<span class="sd">    nodes. It combines the tree like data structure of a tree while</span>
<span class="sd">    extending it with the deep indexable properties of Dimensioned</span>
<span class="sd">    and LabelledData objects.</span>
<span class="sd">    """</span>

    <span class="n">group</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">'ViewableTree'</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">_deep_indexable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">items</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Dimensioned</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_items</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="s1">'id'</span><span class="p">,</span> <span class="s1">'plot_id'</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="n">AttrTree</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">Dimensioned</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_process_items</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="s2">"Processes list of items assigning unique paths to each."</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">cls</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vals</span><span class="o">.</span><span class="n">data</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_unpack_paths</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_deduplicate_items</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">items</span>


    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Ensure that object does not try to reference its parent during</span>
<span class="sd">        unpickling.</span>
<span class="sd">        """</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'parent'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">'parent'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AttrTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'parent'</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_deduplicate_items</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="s2">"Deduplicates assigned paths by incrementing numbering"</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">path</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">counter</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">items</span>

        <span class="n">new_items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">counter</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">int_to_roman</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">path</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">counts</span><span class="p">[</span><span class="n">path</span><span class="p">]:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">int_to_roman</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">path</span><span class="p">]</span><span class="o">+</span><span class="n">inc</span><span class="p">),)</span>
                    <span class="n">inc</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_items</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">path</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">new_items</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_unpack_paths</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">objs</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Recursively unpacks lists and ViewableTree-like objects, accumulating</span>
<span class="sd">        into the supplied list of items.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">cls</span><span class="p">:</span>
            <span class="n">objs</span> <span class="o">=</span> <span class="n">objs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">item</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">cls</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_unpack_paths</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">if</span> <span class="n">new</span> <span class="k">else</span> <span class="n">path</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">make_path_unique</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
            <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_path</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"Whether items in tree have uniform dimensions"</span>
        <span class="kn">from</span> <span class="nn">.traversal</span> <span class="kn">import</span> <span class="n">uniform</span>
        <span class="k">return</span> <span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="ViewableTree.dimension_values"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.html#holoviews.core.ViewableTree.dimension_values">[docs]</a>    <span class="k">def</span> <span class="nf">dimension_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Return the values along the requested dimension.</span>

<span class="sd">        Concatenates values on all nodes with requested dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: The dimension to return values for</span>
<span class="sd">            expanded (bool, optional): Whether to expand values</span>
<span class="sd">                Whether to return the expanded values, behavior depends</span>
<span class="sd">                on the type of data:</span>
<span class="sd">                  * Columnar: If false returns unique values</span>
<span class="sd">                  * Geometry: If false returns scalar values per geometry</span>
<span class="sd">                  * Gridded: If false returns 1D coordinates</span>
<span class="sd">            flat (bool, optional): Whether to flatten array</span>

<span class="sd">        Returns:</span>
<span class="sd">            NumPy array of values along the requested dimension</span>
<span class="sd">        """</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="n">all_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">all_dims</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">dimension_values</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span>
                      <span class="k">if</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">dimensions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vals</span> <span class="k">if</span> <span class="n">expanded</span> <span class="k">else</span> <span class="n">util</span><span class="o">.</span><span class="n">unique_array</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">dimension_values</span><span class="p">(</span>
                <span class="n">dimension</span><span class="p">,</span> <span class="n">expanded</span><span class="p">,</span> <span class="n">flat</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>
</pre></div>
</div>
<!-- Previous / next buttons -->
<div class="prev-next-area">
</div>
</main>
</div>
</div>
<script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
<div class="container">
<div class="footer-item">
<p class="copyright">
    Â© Copyright 2021 HoloViz developers.<br/>
</p>
</div>
<div class="footer-item">
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.1.<br/>
</p>
</div>
</div>
</footer>
</body>
</html>