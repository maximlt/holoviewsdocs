
<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>holoviews.core.data â€” HoloViews v1.14.7a1</title>
<link href="../../../_static/css/theme.css" rel="stylesheet"/>
<link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet"/>
<link href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet"/>
<link as="font" crossorigin="" href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link href="../../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/css/blank.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/togglebutton.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/mystnb.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/graphviz.css" rel="stylesheet" type="text/css"/>
<link href="../../../_static/copybutton.css" rel="stylesheet" type="text/css">
<link href="../../../_static/nbsite.css" rel="stylesheet" type="text/css">
<link href="../../../_static/css/custom.css" rel="stylesheet" type="text/css">
<link as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js" rel="preload">
<script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
<script src="../../../_static/jquery.js"></script>
<script src="../../../_static/underscore.js"></script>
<script src="../../../_static/doctools.js"></script>
<script src="../../../_static/togglebutton.js"></script>
<script src="../../../_static/clipboard.min.js"></script>
<script src="../../../_static/copybutton.js"></script>
<script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
<link href="../../../_static/favicon.ico" rel="shortcut icon"/>
<link href="../../../about.html" rel="author" title="About these documents">
<link href="../../../genindex.html" rel="index" title="Index">
<link href="../../../search.html" rel="search" title="Search"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="None" name="docsearch:language"/>
<!-- Google Analytics -->
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-61554933-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>
</link></link></link></link></link></link></head>
<body data-offset="80" data-spy="scroll" data-target="#bd-toc-nav">
<div class="container-fluid" id="banner"></div>
<nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">
<div id="navbar-start">
<a class="navbar-brand" href="../../../index.html">
<img alt="logo" class="logo" src="../../../_static/logo_horizontal.png"/>
</a>
</div>
<button aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbar-collapsible" data-toggle="collapse" type="button">
<span class="navbar-toggler-icon"></span>
</button>
<div class="col-lg-9 collapse navbar-collapse" id="navbar-collapsible">
<div class="mr-auto" id="navbar-center">
<div class="navbar-center-item">
<ul class="navbar-nav" id="navbar-main-elements">
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../index.html">
  Home
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../reference/index.html">
  Reference Gallery
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../releases.html">
  Releases
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../reference_manual/index.html">
  API
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../FAQ.html">
  FAQ
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../roadmap.html">
  Roadmap
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference external nav-link" href="https://github.com/holoviz/holoviews">
  Github source
 </a>
</li>
<li class="toctree-l1 nav-item">
<a class="reference internal nav-link" href="../../../about.html">
  About
 </a>
</li>
</ul>
</div>
</div>
<div id="navbar-end">
<div class="navbar-end-item">
<ul aria-label="Icon Links" class="navbar-nav" id="navbar-icon-links">
<li class="nav-item">
<a class="nav-link" href="https://github.com/holoviz/holoviews" rel="noopener" target="_blank" title="GitHub">
<span><i class="fab fa-github-square"></i></span>
<label class="sr-only">GitHub</label>
</a>
</li>
<li class="nav-item">
<a class="nav-link" href="https://twitter.com/holoviews" rel="noopener" target="_blank" title="Twitter">
<span><i class="fab fa-twitter-square"></i></span>
<label class="sr-only">Twitter</label>
</a>
</li>
<li class="nav-item">
<a class="nav-link" href="https://discourse.holoviz.org/" rel="noopener" target="_blank" title="Discourse">
<span><i class="fab fa-discourse"></i></span>
<label class="sr-only">Discourse</label>
</a>
</li>
</ul>
</div>
</div>
</div>
</div>
</nav>
<div class="container-xl">
<div class="row">
<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="col-12 col-md-3 bd-sidebar"><form action="../../../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="icon fas fa-search"></i>
<input aria-label="Search the docs ..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search the docs ..." type="search"/>
</form><nav aria-label="Main navigation" class="bd-links" id="bd-docs-nav">
<div class="bd-toc-item active">
</div>
</nav>
</div>
<div class="d-none d-xl-block col-xl-2 bd-toc">
</div>
<main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
<div>
<h1>Source code for holoviews.core.data</h1><div class="highlight"><pre>
<span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">itertools.izip</span> <span class="k">as</span> <span class="nn">zip</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">param</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span> <span class="c1"># noqa</span>

<span class="kn">from</span> <span class="nn">param.parameterized</span> <span class="kn">import</span> <span class="n">add_metaclass</span><span class="p">,</span> <span class="n">ParameterizedMetaclass</span>

<span class="kn">from</span> <span class="nn">..accessors</span> <span class="kn">import</span> <span class="n">Redim</span>
<span class="kn">from</span> <span class="nn">..dimension</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Dimension</span><span class="p">,</span> <span class="n">Dimensioned</span><span class="p">,</span> <span class="n">LabelledData</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">,</span> <span class="n">process_dimensions</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..element</span> <span class="kn">import</span> <span class="n">Element</span>
<span class="kn">from</span> <span class="nn">..ndmapping</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">MultiDimensionalMapping</span>
<span class="kn">from</span> <span class="nn">..spaces</span> <span class="kn">import</span> <span class="n">HoloMap</span><span class="p">,</span> <span class="n">DynamicMap</span>

<span class="kn">from</span> <span class="nn">.array</span> <span class="kn">import</span> <span class="n">ArrayInterface</span>             <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.cudf</span> <span class="kn">import</span> <span class="n">cuDFInterface</span>               <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.dask</span> <span class="kn">import</span> <span class="n">DaskInterface</span>               <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.dictionary</span> <span class="kn">import</span> <span class="n">DictInterface</span>         <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.grid</span> <span class="kn">import</span> <span class="n">GridInterface</span>               <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.ibis</span> <span class="kn">import</span> <span class="n">IbisInterface</span>               <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.interface</span> <span class="kn">import</span> <span class="n">Interface</span><span class="p">,</span> <span class="n">iloc</span><span class="p">,</span> <span class="n">ndloc</span> <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.multipath</span> <span class="kn">import</span> <span class="n">MultiInterface</span>         <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">ImageInterface</span>             <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.pandas</span> <span class="kn">import</span> <span class="n">PandasInterface</span>           <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.spatialpandas</span> <span class="kn">import</span> <span class="n">SpatialPandasInterface</span>     <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.spatialpandas_dask</span> <span class="kn">import</span> <span class="n">DaskSpatialPandasInterface</span> <span class="c1"># noqa (API import)</span>
<span class="kn">from</span> <span class="nn">.xarray</span> <span class="kn">import</span> <span class="n">XArrayInterface</span>           <span class="c1"># noqa (API import)</span>

<span class="c1"># Ensures correct holoviews.core.util is sourced</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span>

<span class="n">default_datatype</span> <span class="o">=</span> <span class="s1">'dataframe'</span>

<span class="n">datatypes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'dataframe'</span><span class="p">,</span> <span class="s1">'dictionary'</span><span class="p">,</span> <span class="s1">'grid'</span><span class="p">,</span> <span class="s1">'xarray'</span><span class="p">,</span> <span class="s1">'multitabular'</span><span class="p">,</span>
             <span class="s1">'spatialpandas'</span><span class="p">,</span> <span class="s1">'dask_spatialpandas'</span><span class="p">,</span> <span class="s1">'dask'</span><span class="p">,</span> <span class="s1">'cuDF'</span><span class="p">,</span> <span class="s1">'array'</span><span class="p">,</span>
             <span class="s1">'ibis'</span><span class="p">]</span>


<div class="viewcode-block" id="concat"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.data.html#holoviews.core.concat">[docs]</a><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Concatenates collection of datasets along NdMapping dimensions.</span>

<span class="sd">    Concatenates multiple datasets wrapped in an NdMapping type along</span>
<span class="sd">    all of its dimensions. Before concatenation all datasets are cast</span>
<span class="sd">    to the same datatype, which may be explicitly defined or</span>
<span class="sd">    implicitly derived from the first datatype that is</span>
<span class="sd">    encountered. For columnar data concatenation adds the columns for</span>
<span class="sd">    the dimensions being concatenated along and then concatenates all</span>
<span class="sd">    the old and new columns. For gridded data a new axis is created</span>
<span class="sd">    for each dimension being concatenated along and then</span>
<span class="sd">    hierarchically concatenates along each dimension.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets: NdMapping of Datasets to concatenate</span>
<span class="sd">        datatype: Datatype to cast data to before concatenation</span>

<span class="sd">    Returns:</span>
<span class="sd">        Concatenated dataset</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">Interface</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataConversion"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.data.html#holoviews.core.DataConversion">[docs]</a><span class="k">class</span> <span class="nc">DataConversion</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    DataConversion is a very simple container object which can be</span>
<span class="sd">    given an existing Dataset Element and provides methods to convert</span>
<span class="sd">    the Dataset into most other Element types.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_element</span> <span class="o">=</span> <span class="n">element</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Generic conversion method for Dataset based Element</span>
<span class="sd">        types. Supply the Dataset Element type to convert to and</span>
<span class="sd">        optionally the key dimensions (kdims), value dimensions</span>
<span class="sd">        (vdims) and the dimensions.  to group over. Converted Columns</span>
<span class="sd">        can be automatically sorted via the sort option and kwargs can</span>
<span class="sd">        be passed through.</span>
<span class="sd">        """</span>
        <span class="n">element_params</span> <span class="o">=</span> <span class="n">new_type</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">objects</span><span class="p">()</span>
        <span class="n">kdim_param</span> <span class="o">=</span> <span class="n">element_params</span><span class="p">[</span><span class="s1">'kdims'</span><span class="p">]</span>
        <span class="n">vdim_param</span> <span class="o">=</span> <span class="n">element_params</span><span class="p">[</span><span class="s1">'vdims'</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kdim_param</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">kdim_param</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">kdim_param</span><span class="o">.</span><span class="n">default</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">nvdim</span> <span class="o">=</span> <span class="n">vdim_param</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vdim_param</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">kdims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kd_filter</span> <span class="o">=</span> <span class="n">groupby</span> <span class="ow">or</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kd_filter</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">kd_filter</span> <span class="o">=</span> <span class="p">[</span><span class="n">groupby</span><span class="p">]</span>
            <span class="n">kdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">kd</span> <span class="k">for</span> <span class="n">kd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">kdims</span> <span class="k">if</span> <span class="n">kd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kd_filter</span><span class="p">][:</span><span class="n">ndim</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">kdims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kdims</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">kdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">kdims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vdims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">vdims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kdims</span><span class="p">][:</span><span class="n">nvdim</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vdims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vdims</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">vdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">vdims</span><span class="p">]</span>

        <span class="c1"># Checks Element type supports dimensionality</span>
        <span class="n">type_name</span> <span class="o">=</span> <span class="n">new_type</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">for</span> <span class="n">dim_type</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">'kdims'</span><span class="p">,</span> <span class="n">kdims</span><span class="p">),</span> <span class="p">(</span><span class="s1">'vdims'</span><span class="p">,</span> <span class="n">vdims</span><span class="p">)):</span>
            <span class="n">min_d</span><span class="p">,</span> <span class="n">max_d</span> <span class="o">=</span> <span class="n">element_params</span><span class="p">[</span><span class="n">dim_type</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">min_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_d</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">max_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_d</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> must be between length </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">."</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">type_name</span><span class="p">,</span> <span class="n">dim_type</span><span class="p">,</span> <span class="n">min_d</span><span class="p">,</span> <span class="n">max_d</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">groupby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">groupby</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">kdims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kdims</span><span class="o">+</span><span class="n">vdims</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">groupby</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupby</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">groupby</span> <span class="o">=</span> <span class="p">[</span><span class="n">groupby</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">gridded</span><span class="p">:</span>
            <span class="n">dropped_kdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">kd</span> <span class="k">for</span> <span class="n">kd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">kdims</span> <span class="k">if</span> <span class="n">kd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">+</span><span class="n">kdims</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dropped_kdims</span><span class="p">:</span>
                <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">groupby</span><span class="o">+</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">interface</span><span class="p">,</span> <span class="n">PandasInterface</span><span class="p">):</span>
                <span class="n">ds_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span>
                <span class="n">ds_kdims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds_dims</span> <span class="k">else</span> <span class="n">d</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">+</span><span class="n">kdims</span><span class="p">]</span>
                <span class="n">ds_vdims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds_dims</span> <span class="k">else</span> <span class="n">d</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">vdims</span><span class="p">]</span>
                <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">kdims</span><span class="o">=</span><span class="n">ds_kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="n">ds_vdims</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">groupby</span><span class="o">+</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'kdims'</span><span class="p">:</span> <span class="p">[</span><span class="n">selected</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">kd</span> <span class="ow">in</span> <span class="n">kdims</span><span class="p">],</span>
                  <span class="s1">'vdims'</span><span class="p">:</span> <span class="p">[</span><span class="n">selected</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">vd</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">vd</span> <span class="ow">in</span> <span class="n">vdims</span><span class="p">],</span>
                  <span class="s1">'label'</span><span class="p">:</span> <span class="n">selected</span><span class="o">.</span><span class="n">label</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">selected</span><span class="o">.</span><span class="n">group</span> <span class="o">!=</span> <span class="n">selected</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="s1">'existing'</span><span class="p">)[</span><span class="s1">'group'</span><span class="p">]</span><span class="o">.</span><span class="n">default</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">'group'</span><span class="p">]</span> <span class="o">=</span> <span class="n">selected</span><span class="o">.</span><span class="n">group</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kdims</span><span class="p">)</span> <span class="o">==</span> <span class="n">selected</span><span class="o">.</span><span class="n">ndims</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">groupby</span><span class="p">:</span>
            <span class="c1"># Propagate dataset</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">'dataset'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">dataset</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">'pipeline'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">_pipeline</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">new_type</span><span class="p">(</span><span class="n">selected</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="k">if</span> <span class="n">sort</span> <span class="k">else</span> <span class="n">element</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">selected</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupby</span><span class="p">,</span> <span class="n">container_type</span><span class="o">=</span><span class="n">HoloMap</span><span class="p">,</span>
                                 <span class="n">group_type</span><span class="o">=</span><span class="n">new_type</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort</span><span class="p">(),</span> <span class="p">[</span><span class="n">new_type</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">group</span></div>


<div class="viewcode-block" id="disable_pipeline"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.data.html#holoviews.core.disable_pipeline">[docs]</a><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">disable_pipeline</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    Disable PipelineMeta class from storing pipelines.</span>
<span class="sd">    """</span>
    <span class="n">PipelineMeta</span><span class="o">.</span><span class="n">disable</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">PipelineMeta</span><span class="o">.</span><span class="n">disable</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="PipelineMeta"><a class="viewcode-back" href="../../../reference_manual/holoviews.core.data.html#holoviews.core.PipelineMeta">[docs]</a><span class="k">class</span> <span class="nc">PipelineMeta</span><span class="p">(</span><span class="n">ParameterizedMetaclass</span><span class="p">):</span>

    <span class="c1"># Public methods that should not be wrapped</span>
    <span class="n">blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'__init__'</span><span class="p">,</span> <span class="s1">'clone'</span><span class="p">]</span>

    <span class="n">disable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">classdict</span><span class="p">:</span>
            <span class="n">method_fn</span> <span class="o">=</span> <span class="n">classdict</span><span class="p">[</span><span class="n">method_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">mcs</span><span class="o">.</span><span class="n">blacklist</span> <span class="ow">or</span> <span class="n">method_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'_'</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method_fn</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
                <span class="n">classdict</span><span class="p">[</span><span class="n">method_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">.</span><span class="n">pipelined</span><span class="p">(</span><span class="n">method_fn</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>

        <span class="n">inst</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inst</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">pipelined</span><span class="p">(</span><span class="n">method_fn</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">method_fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">pipelined_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">...operation.element</span> <span class="kn">import</span> <span class="n">method</span> <span class="k">as</span> <span class="n">method_op</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">inst_pipeline</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="s1">'_pipeline'</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">in_method</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">_in_method</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_method</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">_in_method</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">method_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">PipelineMeta</span><span class="o">.</span><span class="n">disable</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>

                <span class="n">op</span> <span class="o">=</span> <span class="n">method_op</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span>
                    <span class="n">input_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">),</span>
                    <span class="n">method_name</span><span class="o">=</span><span class="n">method_name</span><span class="p">,</span>
                    <span class="n">args</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                    <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">in_method</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">_pipeline</span> <span class="o">=</span> <span class="n">inst_pipeline</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span>
                            <span class="n">operations</span><span class="o">=</span><span class="n">inst_pipeline</span><span class="o">.</span><span class="n">operations</span> <span class="o">+</span> <span class="p">[</span><span class="n">op</span><span class="p">],</span>
                            <span class="n">output_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">),</span>
                        <span class="p">)</span>

                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">MultiDimensionalMapping</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                                <span class="n">getitem_op</span> <span class="o">=</span> <span class="n">method_op</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span>
                                    <span class="n">input_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">),</span>
                                    <span class="n">method_name</span><span class="o">=</span><span class="s1">'__getitem__'</span><span class="p">,</span>
                                    <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                                <span class="p">)</span>
                                <span class="n">element</span><span class="o">.</span><span class="n">_pipeline</span> <span class="o">=</span> <span class="n">inst_pipeline</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span>
                                    <span class="n">operations</span><span class="o">=</span><span class="n">inst_pipeline</span><span class="o">.</span><span class="n">operations</span> <span class="o">+</span> <span class="p">[</span>
                                        <span class="n">op</span><span class="p">,</span> <span class="n">getitem_op</span>
                                    <span class="p">],</span>
                                    <span class="n">output_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">),</span>
                                <span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">in_method</span><span class="p">:</span>
                    <span class="n">inst</span><span class="o">.</span><span class="n">_in_method</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">pipelined_fn</span></div>


<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset">[docs]</a><span class="nd">@add_metaclass</span><span class="p">(</span><span class="n">PipelineMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Dataset</span><span class="p">(</span><span class="n">Element</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Dataset provides a general baseclass for Element types that</span>
<span class="sd">    contain structured data and supports a range of data formats.</span>

<span class="sd">    The Dataset class supports various methods offering a consistent</span>
<span class="sd">    way of working with the stored data regardless of the storage</span>
<span class="sd">    format used. These operations include indexing, selection and</span>
<span class="sd">    various ways of aggregating or collapsing the data with a supplied</span>
<span class="sd">    function.</span>
<span class="sd">    """</span>

    <span class="n">datatype</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">datatypes</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">        A priority list of the data types to be used for storage</span>
<span class="s2">        on the .data attribute. If the input supplied to the element</span>
<span class="s2">        constructor cannot be put into the requested format, the next</span>
<span class="s2">        format listed will be used until a suitable format is found (or</span>
<span class="s2">        the data fails to be understood)."""</span><span class="p">)</span>

    <span class="n">group</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">'Dataset'</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># In the 1D case the interfaces should not automatically add x-values</span>
    <span class="c1"># to supplied data</span>
    <span class="n">_auto_indexable_1d</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Define a class used to transform Datasets into other Element types</span>
    <span class="n">_conversion_interface</span> <span class="o">=</span> <span class="n">DataConversion</span>

    <span class="c1"># Whether the key dimensions are specified as bins</span>
    <span class="n">_binned</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_vdim_reductions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_kdim_reductions</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Allows casting a DynamicMap to an Element class like hv.Curve, by applying the</span>
<span class="sd">        class to each underlying element.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DynamicMap</span><span class="p">):</span>
            <span class="n">class_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">repr_kdims</span> <span class="o">=</span> <span class="s1">'kdims=</span><span class="si">%r</span><span class="s1">'</span> <span class="o">%</span> <span class="n">kdims</span> <span class="k">if</span> <span class="n">kdims</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">repr_vdims</span> <span class="o">=</span> <span class="s1">'vdims=</span><span class="si">%r</span><span class="s1">'</span> <span class="o">%</span> <span class="n">vdims</span> <span class="k">if</span> <span class="n">vdims</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">repr_kwargs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                           <span class="k">if</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">extras</span> <span class="o">=</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="p">[</span><span class="n">repr_kdims</span><span class="p">,</span> <span class="n">repr_vdims</span><span class="p">,</span> <span class="n">repr_kwargs</span><span class="p">]</span>
                               <span class="k">if</span> <span class="n">el</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>
            <span class="n">extras</span> <span class="o">=</span> <span class="s1">', '</span> <span class="o">+</span> <span class="n">extras</span> <span class="k">if</span> <span class="n">extras</span> <span class="k">else</span> <span class="s1">''</span>
            <span class="n">apply_args</span><span class="o">=</span> <span class="s1">'hv.</span><span class="si">{class_name}{extras}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="o">=</span><span class="n">class_name</span><span class="p">,</span>
                                                         <span class="n">extras</span><span class="o">=</span><span class="n">extras</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">"Cannot construct a </span><span class="si">{class_name}</span><span class="s2"> from the supplied object of type DynamicMap. Implicitly creating a DynamicMap of </span><span class="si">{class_name}</span><span class="s2"> objects, but instead please explicitly call .apply(</span><span class="si">{apply_args}</span><span class="s2">) on the supplied DynamicMap."</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="o">=</span><span class="n">class_name</span><span class="p">,</span> <span class="n">apply_args</span><span class="o">=</span><span class="n">apply_args</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">per_element</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="n">vdims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">...operation.element</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">chain</span> <span class="k">as</span> <span class="n">chain_op</span><span class="p">,</span> <span class="n">factory</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_method</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">input_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">dataset_provided</span> <span class="o">=</span> <span class="s1">'dataset'</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="n">input_dataset</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'dataset'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">input_pipeline</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'pipeline'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">input_transforms</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'transforms'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Element</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">'kdims'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">'kdims'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">kd</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">kd</span>
                    <span class="k">for</span> <span class="n">kd</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'kdims'</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="s1">'kdims'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">'vdims'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">vd</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vd</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">vd</span>
                    <span class="k">for</span> <span class="n">vd</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'vdims'</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="n">pvals</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">l</span><span class="p">,</span> <span class="n">pvals</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'group'</span><span class="p">,</span> <span class="s1">'label'</span><span class="p">]</span>
                           <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">pvals</span> <span class="ow">and</span> <span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset_provided</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">_dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">input_dataset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_dataset</span>
            <span class="k">if</span> <span class="n">input_pipeline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">input_pipeline</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pipeline</span>
            <span class="k">if</span> <span class="n">input_transforms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">input_transforms</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_transforms</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">process_dimensions</span><span class="p">(</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="p">))</span>
        <span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'kdims'</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'vdims'</span><span class="p">)</span>

        <span class="n">validate_vdims</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'_validate_vdims'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">initialized</span> <span class="o">=</span> <span class="n">Interface</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="p">,</span>
                                           <span class="n">datatype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'datatype'</span><span class="p">))</span>
        <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">extra_kws</span><span class="p">)</span> <span class="o">=</span> <span class="n">initialized</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_kws</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validate_vdims</span><span class="p">)</span>

        <span class="c1"># Handle _pipeline property</span>
        <span class="k">if</span> <span class="n">input_pipeline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_pipeline</span> <span class="o">=</span> <span class="n">chain_op</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'kdims'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'vdims'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span>
        <span class="n">init_op</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span>
            <span class="n">output_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vdims</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pipeline</span> <span class="o">=</span> <span class="n">input_pipeline</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span>
            <span class="n">operations</span><span class="o">=</span><span class="n">input_pipeline</span><span class="o">.</span><span class="n">operations</span> <span class="o">+</span> <span class="p">[</span><span class="n">init_op</span><span class="p">],</span>
            <span class="n">output_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">input_transforms</span> <span class="ow">or</span> <span class="p">[]</span>

        <span class="c1"># On lazy interfaces this allows keeping an evaluated version</span>
        <span class="c1"># of the dataset in memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Handle initializing the dataset property.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span> <span class="o">=</span> <span class="n">input_dataset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dataset_provided</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">input_data</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'kdims'</span><span class="p">:</span> <span class="n">input_data</span><span class="o">.</span><span class="n">kdims</span><span class="p">,</span> <span class="s1">'vdims'</span><span class="p">:</span> <span class="n">input_data</span><span class="o">.</span><span class="n">vdims</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pipeline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">transforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_validate_vdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_binned'</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="o">.</span><span class="n">_binned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binned</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"Ensures pipelines are dropped"</span>
        <span class="n">obj_dict</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">'_pipeline'</span> <span class="ow">in</span> <span class="n">obj_dict</span><span class="p">:</span>
            <span class="n">pipeline</span> <span class="o">=</span> <span class="n">obj_dict</span><span class="p">[</span><span class="s1">'_pipeline'</span><span class="p">]</span>
            <span class="n">obj_dict</span><span class="p">[</span><span class="s1">'_pipeline'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span><span class="n">operations</span><span class="o">=</span><span class="n">pipeline</span><span class="o">.</span><span class="n">operations</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">'_transforms'</span> <span class="ow">in</span> <span class="n">obj_dict</span><span class="p">:</span>
            <span class="n">obj_dict</span><span class="p">[</span><span class="s1">'_transforms'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">obj_dict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">redim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Redim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'dataset'</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The Dataset that this object was created from</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Dataset</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">unique_iterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="o">+</span><span class="n">Dataset</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pipeline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">_validate_vdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_binned'</span><span class="p">):</span>
                <span class="n">dataset</span><span class="o">.</span><span class="n">_binned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binned</span>
            <span class="k">return</span> <span class="n">dataset</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_validate_vdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Chain operation that evaluates the sequence of operations that was</span>
<span class="sd">        used to create this object, starting with the Dataset stored in</span>
<span class="sd">        dataset property</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pipeline</span>

<div class="viewcode-block" id="Dataset.compute"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Computes the data to a data format that stores the daata in</span>
<span class="sd">        memory, e.g. a Dask dataframe or array is converted to a</span>
<span class="sd">        Pandas DataFrame or NumPy array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset with the data stored in in-memory format</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.persist"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.persist">[docs]</a>    <span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Persists the results of a lazy data interface to memory to</span>
<span class="sd">        speed up data manipulation and visualization. If the</span>
<span class="sd">        particular data backend already holds the data in memory</span>
<span class="sd">        this is a no-op. Unlike the compute method this maintains</span>
<span class="sd">        the same data type.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset with the data persisted to memory</span>
<span class="sd">        """</span>
        <span class="n">persisted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">persist</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">persisted</span><span class="o">.</span><span class="n">interface</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">persisted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached</span> <span class="o">=</span> <span class="n">persisted</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Dataset.closest"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.closest">[docs]</a>    <span class="k">def</span> <span class="nf">closest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Snaps coordinate(s) to closest coordinate in Dataset</span>

<span class="sd">        Args:</span>
<span class="sd">            coords: List of coordinates expressed as tuples</span>
<span class="sd">            **kwargs: Coordinates defined as keyword pairs</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of tuples of the snapped coordinates</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: Raised if snapping is not supported</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Closest method currently only "</span>
                                      <span class="s2">"implemented for 1D Elements"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Closest method currently only "</span>
                                          <span class="s2">"supports 1D indexes"</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">samples</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">samples</span><span class="p">]</span>

        <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xs</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">'SO'</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Closest only supported for numeric types"</span><span class="p">)</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xs</span><span class="o">-</span><span class="n">coord</span><span class="p">))</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)(</span><span class="n">xs</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">idxs</span><span class="p">)]</span></div>


<div class="viewcode-block" id="Dataset.sort"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Sorts the data by the values along the supplied dimensions.</span>

<span class="sd">        Args:</span>
<span class="sd">            by: Dimension(s) to sort by</span>
<span class="sd">            reverse (bool, optional): Reverse sort order</span>

<span class="sd">        Returns:</span>
<span class="sd">            Sorted Dataset</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">by</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">by</span> <span class="o">=</span> <span class="p">[</span><span class="n">by</span><span class="p">]</span>
        <span class="n">sorted_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">sorted_columns</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.range"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.range">[docs]</a>    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">data_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dimension_range</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Return the lower and upper bounds of values along dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: The dimension to compute the range on.</span>
<span class="sd">            data_range (bool): Compute range from data values</span>
<span class="sd">            dimension_range (bool): Include Dimension ranges</span>
<span class="sd">                Whether to include Dimension range and soft_range</span>
<span class="sd">                in range calculation</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple containing the lower and upper bound</span>
<span class="sd">        """</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">data_range</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dimension_range</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">range</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dimension_range</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dim</span><span class="o">.</span><span class="n">range</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="ow">and</span> <span class="n">data_range</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dimension_range</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">dimension_range</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="n">soft_range</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.add_dimension"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.add_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">add_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">dim_pos</span><span class="p">,</span> <span class="n">dim_val</span><span class="p">,</span> <span class="n">vdim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Adds a dimension and its values to the Dataset</span>

<span class="sd">        Requires the dimension name or object, the desired position in</span>
<span class="sd">        the key dimensions and a key value scalar or array of values,</span>
<span class="sd">        matching the length or shape of the Dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: Dimension or dimension spec to add</span>
<span class="sd">            dim_pos (int): Integer index to insert dimension at</span>
<span class="sd">            dim_val (scalar or ndarray): Dimension value(s) to add</span>
<span class="sd">            vdim: Disabled, this type does not have value dimensions</span>
<span class="sd">            **kwargs: Keyword arguments passed to the cloned element</span>
<span class="sd">        Returns:</span>
<span class="sd">            Cloned object containing the new dimension</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">dimension</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dimension</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'</span><span class="si">{dim}</span><span class="s1"> dimension already defined'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dimension</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">vdim</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span><span class="p">[:]</span>
            <span class="n">dims</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dim_pos</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">vdims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">dim_pos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="p">[:]</span>
            <span class="n">dims</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dim_pos</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kdims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="p">,</span> <span class="n">ArrayInterface</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dim_val</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">datatype</span><span class="o">=</span><span class="p">[</span><span class="n">default_datatype</span><span class="p">])</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">add_dimension</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">dim_pos</span><span class="p">,</span> <span class="n">dim_val</span><span class="p">,</span> <span class="n">vdim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">add_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">dim_pos</span><span class="p">,</span> <span class="n">dim_val</span><span class="p">,</span> <span class="n">vdim</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">dimensions</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.select"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">selection_specs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">selection</span><span class="p">):</span>
        <span class="sd">"""Applies selection by dimension name</span>

<span class="sd">        Applies a selection along the dimensions of the object using</span>
<span class="sd">        keyword arguments. The selection may be narrowed to certain</span>
<span class="sd">        objects using selection_specs. For container objects the</span>
<span class="sd">        selection will be applied to all children as well.</span>

<span class="sd">        Selections may select a specific value, slice or set of values:</span>

<span class="sd">        * value: Scalar values will select rows along with an exact</span>
<span class="sd">                 match, e.g.:</span>

<span class="sd">            ds.select(x=3)</span>

<span class="sd">        * slice: Slices may be declared as tuples of the upper and</span>
<span class="sd">                 lower bound, e.g.:</span>

<span class="sd">            ds.select(x=(0, 3))</span>

<span class="sd">        * values: A list of values may be selected using a list or</span>
<span class="sd">                  set, e.g.:</span>

<span class="sd">            ds.select(x=[0, 1, 2])</span>

<span class="sd">        * predicate expression: A holoviews.dim expression, e.g.:</span>

<span class="sd">            from holoviews import dim</span>
<span class="sd">            ds.select(selection_expr=dim('x') % 2 == 0)</span>

<span class="sd">        Args:</span>
<span class="sd">            selection_expr: holoviews.dim predicate expression</span>
<span class="sd">                specifying selection.</span>
<span class="sd">            selection_specs: List of specs to match on</span>
<span class="sd">                A list of types, functions, or type[.group][.label]</span>
<span class="sd">                strings specifying which objects to apply the</span>
<span class="sd">                selection on.</span>
<span class="sd">            **selection: Dictionary declaring selections by dimension</span>
<span class="sd">                Selections can be scalar values, tuple ranges, lists</span>
<span class="sd">                of discrete values and boolean arrays</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns an Dimensioned object containing the selected data</span>
<span class="sd">            or a scalar if a single value was selected</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">...util.transform</span> <span class="kn">import</span> <span class="n">dim</span>
        <span class="k">if</span> <span class="n">selection_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection_expr</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"""</span><span class="se">\</span>
<span class="s2">The first positional argument to the Dataset.select method is expected to be a</span>
<span class="s2">holoviews.util.transform.dim expression. Use the selection_specs keyword</span>
<span class="s2">argument to specify a selection specification"""</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">selection_specs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection_specs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">selection_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">selection_specs</span><span class="p">]</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim_name</span><span class="p">:</span> <span class="n">sel</span> <span class="k">for</span> <span class="n">dim_name</span><span class="p">,</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">selection</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                     <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="s1">'selection_mask'</span><span class="p">]}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">selection_specs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">selection_specs</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">selection</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">selection_expr</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Handle selection dim expression</span>
        <span class="k">if</span> <span class="n">selection_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">selection_expr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'selection_mask'</span><span class="p">:</span> <span class="n">mask</span><span class="p">}</span>

        <span class="c1"># Handle selection kwargs</span>
        <span class="k">if</span> <span class="n">selection</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.reindex"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.reindex">[docs]</a>    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Reindexes Dataset dropping static or supplied kdims</span>

<span class="sd">        Creates a new object with a reordered or reduced set of key</span>
<span class="sd">        dimensions. By default drops all non-varying key dimensions.x</span>

<span class="sd">        Args:</span>
<span class="sd">            kdims (optional): New list of key dimensionsx</span>
<span class="sd">            vdims (optional): New list of value dimensions</span>

<span class="sd">        Returns:</span>
<span class="sd">            Reindexed object</span>
<span class="sd">        """</span>
        <span class="n">gridded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">gridded</span>
        <span class="n">scalars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">gridded</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="p">]</span>
            <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">coords</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">kdims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If no key dimensions are defined and interface is gridded</span>
            <span class="c1"># drop all scalar key dimensions</span>
            <span class="n">key_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">vdims</span> <span class="ow">or</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vdims</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">scalars</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kdims</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">key_dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">kdims</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kdims</span><span class="p">]</span>
        <span class="n">dropped</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">key_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">scalars</span><span class="p">]</span>

        <span class="n">new_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">vdims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">val_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">kdims</span> <span class="ow">or</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kdims</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val_dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vdims</span><span class="p">]</span>
            <span class="n">new_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vdim_reductions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_dims</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_dims</span><span class="p">,</span> <span class="n">val_dims</span><span class="p">)</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span>
        <span class="k">if</span> <span class="n">gridded</span> <span class="ow">and</span> <span class="n">dropped</span><span class="p">:</span>
            <span class="n">interfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">interfaces</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="p">[</span><span class="n">dt</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">datatype</span> <span class="k">if</span> <span class="ow">not</span>
                        <span class="nb">getattr</span><span class="p">(</span><span class="n">interfaces</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">'gridded'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">key_dims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="n">val_dims</span><span class="p">,</span>
                          <span class="n">new_type</span><span class="o">=</span><span class="n">new_type</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Allows slicing and selecting values in the Dataset object.</span>
<span class="sd">        Supports multiple indexing modes:</span>

<span class="sd">           (1) Slicing and indexing along the values of each dimension</span>
<span class="sd">               in the columns object using either scalars, slices or</span>
<span class="sd">               sets of values.</span>
<span class="sd">           (2) Supplying the name of a dimension as the first argument</span>
<span class="sd">               will return the values along that dimension as a numpy</span>
<span class="sd">               array.</span>
<span class="sd">           (3) Slicing of all key dimensions and selecting a single</span>
<span class="sd">               value dimension by name.</span>
<span class="sd">           (4) A boolean array index matching the length of the Dataset</span>
<span class="sd">               object.</span>
<span class="sd">        """</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">process_ellipses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">vdim_selection</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="s1">'dtype'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">'kind'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="s1">'b'</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">"Boolean index must match length of sliced object"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selection_mask</span><span class="o">=</span><span class="n">slices</span><span class="p">))</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="p">())</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">slices</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span> <span class="n">slices</span> <span class="o">=</span> <span class="p">(</span><span class="n">slices</span><span class="p">,)</span>
        <span class="n">value_select</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_values</span><span class="p">(</span><span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">slices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">():</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">(</span><span class="s1">'key'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">slices</span><span class="p">))</span>
            <span class="n">value_select</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">],</span>
                                                        <span class="p">(</span><span class="n">Dimension</span><span class="p">,</span><span class="nb">str</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">"</span><span class="si">%r</span><span class="s2"> is not an available value dimension"</span> <span class="o">%</span> <span class="n">slices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">slices</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">**</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value_select</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">value_select</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">vdims</span><span class="o">=</span><span class="p">[</span><span class="n">value_select</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">data</span>


<div class="viewcode-block" id="Dataset.sample"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="p">[],</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">closest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Samples values at supplied coordinates.</span>

<span class="sd">        Allows sampling of element with a list of coordinates matching</span>
<span class="sd">        the key dimensions, returning a new object containing just the</span>
<span class="sd">        selected samples. Supports multiple signatures:</span>

<span class="sd">        Sampling with a list of coordinates, e.g.:</span>

<span class="sd">            ds.sample([(0, 0), (0.1, 0.2), ...])</span>

<span class="sd">        Sampling a range or grid of coordinates, e.g.:</span>

<span class="sd">            1D: ds.sample(3)</span>
<span class="sd">            2D: ds.sample((3, 3))</span>

<span class="sd">        Sampling by keyword, e.g.:</span>

<span class="sd">            ds.sample(x=0)</span>

<span class="sd">        Args:</span>
<span class="sd">            samples: List of nd-coordinates to sample</span>
<span class="sd">            bounds: Bounds of the region to sample</span>
<span class="sd">                Defined as two-tuple for 1D sampling and four-tuple</span>
<span class="sd">                for 2D sampling.</span>
<span class="sd">            closest: Whether to snap to closest coordinates</span>
<span class="sd">            **kwargs: Coordinates specified as keyword pairs</span>
<span class="sd">                Keywords of dimensions and scalar coordinates</span>

<span class="sd">        Returns:</span>
<span class="sd">            Element containing the sampled coordinates</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">samples</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Supply explicit list of samples or kwargs, not both.'</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">sample</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sample</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="n">util</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">xlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bounds</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">samples</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">linsamples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">l</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span> <span class="o">=</span> <span class="n">samples</span>
                <span class="k">if</span> <span class="n">bounds</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">bounds</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                <span class="n">xedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cols</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">yedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">xsamples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">lx</span><span class="o">+</span><span class="n">ux</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">lx</span><span class="p">,</span><span class="n">ux</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xedges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xedges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
                <span class="n">ysamples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ly</span><span class="o">+</span><span class="n">uy</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">ly</span><span class="p">,</span><span class="n">uy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">yedges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>

                <span class="n">Y</span><span class="p">,</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">ysamples</span><span class="p">,</span> <span class="n">xsamples</span><span class="p">)</span>
                <span class="n">linsamples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Regular sampling not implemented "</span>
                                          <span class="s2">"for elements with more than two dimensions."</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">unique_iterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="n">linsamples</span><span class="p">)))</span>

        <span class="c1"># Note: Special handling sampling of gridded 2D data as Curve</span>
        <span class="c1"># may be replaced with more general handling</span>
        <span class="c1"># see https://github.com/holoviz/holoviews/issues/1173</span>
        <span class="kn">from</span> <span class="nn">...element</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Curve</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'dataframe'</span><span class="p">,</span> <span class="s1">'dictionary'</span><span class="p">,</span> <span class="s1">'dask'</span><span class="p">,</span> <span class="s1">'ibis'</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="p">{</span><span class="n">kd</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">kd</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">kd</span> <span class="k">for</span> <span class="n">kd</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sel</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">**</span><span class="n">sel</span><span class="p">)</span>

            <span class="c1"># If a 1D cross-section of 2D space return Curve</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">gridded</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">Curve</span>
                <span class="n">kdims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">kd</span><span class="p">)</span> <span class="k">for</span> <span class="n">kd</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">Table</span>
                <span class="n">kdims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">selection</span><span class="p">):</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="p">[</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">selection</span><span class="p">,)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reindexed</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">new_type</span><span class="o">=</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">kdims</span><span class="p">)</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">reindexed</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="n">kdims</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">vdims</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="n">datatype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">unique_iterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="o">+</span><span class="p">[</span><span class="s1">'dataframe'</span><span class="p">,</span> <span class="s1">'dict'</span><span class="p">]))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="n">new_type</span><span class="p">,</span>
                              <span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">)</span>

        <span class="n">lens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">wrap_tuple</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Sample coordinates must all be of the same length.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">closest</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">util</span><span class="o">.</span><span class="n">wrap_tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">]</span>
        <span class="n">sampled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">sampled</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="n">Table</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.reduce"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">[],</span> <span class="n">function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spreadfn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">reductions</span><span class="p">):</span>
        <span class="sd">"""Applies reduction along the specified dimension(s).</span>

<span class="sd">        Allows reducing the values along one or more key dimension</span>
<span class="sd">        with the supplied function. Supports two signatures:</span>

<span class="sd">        Reducing with a list of dimensions, e.g.:</span>

<span class="sd">            ds.reduce(['x'], np.mean)</span>

<span class="sd">        Defining a reduction using keywords, e.g.:</span>

<span class="sd">            ds.reduce(x=np.mean)</span>

<span class="sd">        Args:</span>
<span class="sd">            dimensions: Dimension(s) to apply reduction on</span>
<span class="sd">                Defaults to all key dimensions</span>
<span class="sd">            function: Reduction operation to apply, e.g. numpy.mean</span>
<span class="sd">            spreadfn: Secondary reduction to compute value spread</span>
<span class="sd">                Useful for computing a confidence interval, spread, or</span>
<span class="sd">                standard deviation.</span>
<span class="sd">            **reductions: Keyword argument defining reduction</span>
<span class="sd">                Allows reduction to be defined as keyword pair of</span>
<span class="sd">                dimension and function</span>

<span class="sd">        Returns:</span>
<span class="sd">            The Dataset after reductions have been applied.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Reduce cannot be applied to value dimensions"</span><span class="p">)</span>
        <span class="n">function</span><span class="p">,</span> <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_map</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">reductions</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">spreadfn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.aggregate"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.aggregate">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spreadfn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Aggregates data on the supplied dimensions.</span>

<span class="sd">        Aggregates over the supplied key dimensions with the defined</span>
<span class="sd">        function or dim_transform specified as a tuple of the transformed</span>
<span class="sd">        dimension name and dim transform.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimensions: Dimension(s) to aggregate on</span>
<span class="sd">                Default to all key dimensions</span>
<span class="sd">            function: Aggregation function or transform to apply</span>
<span class="sd">                Supports both simple functions and dimension transforms</span>
<span class="sd">            spreadfn: Secondary reduction to compute value spread</span>
<span class="sd">                Useful for computing a confidence interval, spread, or</span>
<span class="sd">                standard deviation.</span>
<span class="sd">            **kwargs: Keyword arguments either passed to the aggregation function</span>
<span class="sd">                or to create new names for the transformed variables</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns the aggregated Dataset</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">...util.transform</span> <span class="kn">import</span> <span class="n">dim</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimensions</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">new_type</span><span class="o">=</span><span class="n">Dataset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dimensions</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">()</span> <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">function</span><span class="p">,)</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">apply</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformed</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="n">transformed</span> <span class="o">=</span> <span class="n">transformed</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">transformed</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">new_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="n">min_d</span><span class="p">,</span> <span class="n">max_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="s1">'existing'</span><span class="p">)[</span><span class="s1">'kdims'</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">generic_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ndims</span> <span class="o">&lt;</span> <span class="n">min_d</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">max_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ndims</span> <span class="o">&gt;</span> <span class="n">max_d</span><span class="p">)</span>
        <span class="n">new_type</span> <span class="o">=</span> <span class="n">Dataset</span> <span class="k">if</span> <span class="n">generic_type</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Handle functions</span>
        <span class="n">kdims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spreadfn</span><span class="p">:</span>
                <span class="n">spread_name</span> <span class="o">=</span> <span class="n">spreadfn</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">vdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">vd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">vd</span><span class="p">,</span> <span class="n">vd</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s1">'_'</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">vd</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">spread_name</span><span class="p">]))]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vdims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kdims</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vdims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">([],</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="n">vdims</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="n">new_type</span><span class="p">)</span>

        <span class="n">vdims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vdims</span>
        <span class="n">aggregated</span><span class="p">,</span> <span class="n">dropped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kdims</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">aggregated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">unpack_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggregated</span><span class="p">)</span>
        <span class="n">vdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">vd</span> <span class="k">for</span> <span class="n">vd</span> <span class="ow">in</span> <span class="n">vdims</span> <span class="k">if</span> <span class="n">vd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dropped</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">spreadfn</span><span class="p">:</span>
            <span class="n">error</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">spreadfn</span><span class="p">)</span>
            <span class="n">spread_name</span> <span class="o">=</span> <span class="n">spreadfn</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vdims</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="n">Dataset</span><span class="p">)</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">aggregated</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="n">Dataset</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vdims</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s1">'_'</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">spread_name</span><span class="p">]))</span>
                <span class="n">dvals</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">dimension_values</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">vdims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">combined</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">add_dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dvals</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">vdims</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">vdims</span>
            <span class="k">return</span> <span class="n">combined</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">new_type</span><span class="o">=</span><span class="n">new_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">aggregated</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">aggregated</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Should be checking the dimensions declared on the element are compatible</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">aggregated</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="n">vdims</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">datatype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="s1">'existing'</span><span class="p">)[</span><span class="s1">'datatype'</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">aggregated</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="n">vdims</span><span class="p">,</span>
                                  <span class="n">new_type</span><span class="o">=</span><span class="n">new_type</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.groupby"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.groupby">[docs]</a>    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">[],</span> <span class="n">container_type</span><span class="o">=</span><span class="n">HoloMap</span><span class="p">,</span> <span class="n">group_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Groups object by one or more dimensions</span>

<span class="sd">        Applies groupby operation over the specified dimensions</span>
<span class="sd">        returning an object of type container_type (expected to be</span>
<span class="sd">        dictionary-like) containing the groups.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimensions: Dimension(s) to group by</span>
<span class="sd">            container_type: Type to cast group container to</span>
<span class="sd">            group_type: Type to cast each group to</span>
<span class="sd">            dynamic: Whether to return a DynamicMap</span>
<span class="sd">            **kwargs: Keyword arguments to pass to each group</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns object of supplied container_type containing the</span>
<span class="sd">            groups. If dynamic=True returns a DynamicMap instead.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimensions</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">(</span><span class="s1">'key'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">group_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">group_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
        <span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dynamic</span><span class="p">:</span>
            <span class="n">group_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">kd</span> <span class="k">for</span> <span class="n">kd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span> <span class="k">if</span> <span class="n">kd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
            <span class="n">kdims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'kdims'</span><span class="p">,</span> <span class="n">group_dims</span><span class="p">)]</span>
            <span class="n">drop_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_dims</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kdims</span><span class="p">)</span>
            <span class="n">group_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">)</span>
            <span class="n">group_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">load_subset</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="n">constraint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dim_names</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
                <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">**</span><span class="n">constraint</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">group_type</span><span class="p">(([</span><span class="n">group</span><span class="p">],),</span> <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">,</span>
                                      <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vdims</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">kdims</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">drop_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">gridded</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">group_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">group_kwargs</span><span class="p">)</span>
            <span class="n">dynamic_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">False</span><span class="p">)))</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">DynamicMap</span><span class="p">(</span><span class="n">load_subset</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">dynamic_dims</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_names</span><span class="p">,</span> <span class="n">container_type</span><span class="p">,</span>
                                      <span class="n">group_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.transform"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Transforms the Dataset according to a dimension transform.</span>

<span class="sd">        Transforms may be supplied as tuples consisting of the</span>
<span class="sd">        dimension(s) and the dim transform to apply or keyword</span>
<span class="sd">        arguments mapping from dimension(s) to dim transforms. If the</span>
<span class="sd">        arg or kwarg declares multiple dimensions the dim transform</span>
<span class="sd">        should return a tuple of values for each.</span>

<span class="sd">        A transform may override an existing dimension or add a new</span>
<span class="sd">        one in which case it will be added as an additional value</span>
<span class="sd">        dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            args: Specify the output arguments and transforms as a</span>
<span class="sd">                  tuple of dimension specs and dim transforms</span>
<span class="sd">            drop (bool): Whether to drop all variables not part of the transform</span>
<span class="sd">            keep_index (bool): Whether to keep indexes</span>
<span class="sd">                  Whether to apply transform on datastructure with</span>
<span class="sd">                  index, e.g. pandas.Series or xarray.DataArray,</span>
<span class="sd">                  (important for dask datastructures where index may</span>
<span class="sd">                  be required to align datasets).</span>
<span class="sd">            kwargs: Specify new dimensions in the form new_dim=dim_transform</span>

<span class="sd">        Returns:</span>
<span class="sd">            Transformed dataset with new dimensions</span>
<span class="sd">        """</span>
        <span class="n">drop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'drop'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">keep_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'keep_index'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">transform</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">transforms</span><span class="p">[</span><span class="n">util</span><span class="o">.</span><span class="n">wrap_tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span> <span class="o">=</span> <span class="n">transform</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">signature</span><span class="p">,</span> <span class="n">transform</span> <span class="ow">in</span> <span class="n">transforms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">applied</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">compute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_index</span><span class="o">=</span><span class="n">keep_index</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">signature</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">applied</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">applied</span><span class="p">):</span>
                    <span class="n">new_data</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="n">new_dims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">new_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'image'</span><span class="p">,</span> <span class="s1">'array'</span><span class="p">):</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">datatype</span><span class="o">=</span><span class="p">[</span><span class="n">dt</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">datatype</span> <span class="k">if</span> <span class="n">dt</span> <span class="o">!=</span> <span class="n">ds</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">datatype</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
            <span class="n">kdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">ds</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">new_data</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">kdims</span><span class="p">]</span>
            <span class="n">vdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">ds</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">new_data</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">kdims</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">dimension_name</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">values</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">new_data</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
            <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="n">vdims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">dimension_name</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">values</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">new_data</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">drop</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">kdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">kd</span> <span class="k">for</span> <span class="n">kd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span> <span class="k">if</span> <span class="n">kd</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">kdims</span><span class="o">=</span><span class="n">kdims</span><span class="p">,</span> <span class="n">vdims</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">vdims</span><span class="o">+</span><span class="n">new_dims</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"Number of values in the Dataset."</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"Whether the Dataset contains any values"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"Returns the shape of the data."</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="Dataset.dimension_values"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.dimension_values">[docs]</a>    <span class="k">def</span> <span class="nf">dimension_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Return the values along the requested dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: The dimension to return values for</span>
<span class="sd">            expanded (bool, optional): Whether to expand values</span>
<span class="sd">                Whether to return the expanded values, behavior depends</span>
<span class="sd">                on the type of data:</span>
<span class="sd">                  * Columnar: If false returns unique values</span>
<span class="sd">                  * Geometry: If false returns scalar values per geometry</span>
<span class="sd">                  * Gridded: If false returns 1D coordinates</span>
<span class="sd">            flat (bool, optional): Whether to flatten array</span>

<span class="sd">        Returns:</span>
<span class="sd">            NumPy array of values along the requested dimension</span>
<span class="sd">        """</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">expanded</span><span class="p">,</span> <span class="n">flat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">nodata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Ensure nodata applies to boolean data in py2</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">values</span><span class="o">==</span><span class="n">dim</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="Dataset.get_dimension_type"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.get_dimension_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_dimension_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">"""Get the type of the requested dimension.</span>

<span class="sd">        Type is determined by Dimension.type attribute or common</span>
<span class="sd">        type of the dimension values, otherwise None.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: Dimension to look up by name or by index</span>

<span class="sd">        Returns:</span>
<span class="sd">            Declared type of values along the dimension</span>
<span class="sd">        """</span>
        <span class="n">dim_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_obj</span> <span class="ow">and</span> <span class="n">dim_obj</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dim_obj</span><span class="o">.</span><span class="n">type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">dimension_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_obj</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.dframe"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.dframe">[docs]</a>    <span class="k">def</span> <span class="nf">dframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multi_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""Convert dimension values to DataFrame.</span>

<span class="sd">        Returns a pandas dataframe of columns along each dimension,</span>
<span class="sd">        either completely flat or indexed by key dimensions.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimensions: Dimensions to return as columns</span>
<span class="sd">            multi_index: Convert key dimensions to (multi-)index</span>

<span class="sd">        Returns:</span>
<span class="sd">            DataFrame of columns corresponding to each dimension</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">dframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multi_index</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdims</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="Dataset.columns"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.columns">[docs]</a>    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Convert dimension values to a dictionary.</span>

<span class="sd">        Returns a dictionary of column arrays along each dimension</span>
<span class="sd">        of the element.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimensions: Dimensions to return as columns</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary of arrays for each dimension</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_values</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">])</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"Returns the conversion interface with methods to convert Dataset"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conversion_interface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="Dataset.clone"><a class="viewcode-back" href="../../../reference_manual/holoviews.element.html#holoviews.core.Dataset.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shared_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">):</span>
        <span class="sd">"""Clones the object, overriding data and parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: New data replacing the existing data</span>
<span class="sd">            shared_data (bool, optional): Whether to use existing data</span>
<span class="sd">            new_type (optional): Type to cast object to</span>
<span class="sd">            link (bool, optional): Whether clone should be linked</span>
<span class="sd">                Determines whether Streams and Links attached to</span>
<span class="sd">                original object will be inherited.</span>
<span class="sd">            *args: Additional arguments to pass to constructor</span>
<span class="sd">            **overrides: New keyword arguments to pass to constructor</span>

<span class="sd">        Returns:</span>
<span class="sd">            Cloned object</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="s1">'datatype'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overrides</span><span class="p">:</span>
            <span class="n">datatypes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">datatype</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span>
            <span class="n">overrides</span><span class="p">[</span><span class="s1">'datatype'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">unique_iterator</span><span class="p">(</span><span class="n">datatypes</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">overrides</span><span class="p">[</span><span class="s1">'_validate_vdims'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Allows datatype conversions</span>
            <span class="k">if</span> <span class="n">shared_data</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">if</span> <span class="n">link</span><span class="p">:</span>
                    <span class="n">overrides</span><span class="p">[</span><span class="s1">'plot_id'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_id</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_method</span> <span class="ow">and</span> <span class="s1">'dataset'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overrides</span><span class="p">:</span>
            <span class="n">overrides</span><span class="p">[</span><span class="s1">'dataset'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">shared_data</span><span class="p">,</span> <span class="n">new_type</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">overrides</span><span class="p">)</span></div>

    <span class="c1"># Overrides of superclass methods that are needed so that PipelineMeta</span>
    <span class="c1"># will find them to wrap with pipeline support</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">Dimensioned</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">LabelledData</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">LabelledData</span><span class="o">.</span><span class="n">relabel</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns iloc indexer with support for columnar indexing.</span>

<span class="sd">        Returns an iloc object providing a convenient interface to</span>
<span class="sd">        slice and index into the Dataset using row and column indices.</span>
<span class="sd">        Allow selection by integer index, slice and list of integer</span>
<span class="sd">        indices and boolean arrays.</span>

<span class="sd">        Examples:</span>

<span class="sd">        * Index the first row and column:</span>

<span class="sd">            dataset.iloc[0, 0]</span>

<span class="sd">        * Select rows 1 and 2 with a slice:</span>

<span class="sd">            dataset.iloc[1:3, :]</span>

<span class="sd">        * Select with a list of integer coordinates:</span>

<span class="sd">            dataset.iloc[[0, 2, 3]]</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns ndloc indexer with support for gridded indexing.</span>

<span class="sd">        Returns an ndloc object providing nd-array like indexing for</span>
<span class="sd">        gridded datasets. Follows NumPy array indexing conventions,</span>
<span class="sd">        allowing for indexing, slicing and selecting a list of indices</span>
<span class="sd">        on multi-dimensional arrays using integer indices. The order</span>
<span class="sd">        of array indices is inverted relative to the Dataset key</span>
<span class="sd">        dimensions, e.g. an Image with key dimensions 'x' and 'y' can</span>
<span class="sd">        be indexed with ``image.ndloc[iy, ix]``, where ``iy`` and</span>
<span class="sd">        ``ix`` are integer indices along the y and x dimensions.</span>

<span class="sd">        Examples:</span>

<span class="sd">        * Index value in 2D array:</span>

<span class="sd">            dataset.ndloc[3, 1]</span>

<span class="sd">        * Slice along y-axis of 2D array:</span>

<span class="sd">            dataset.ndloc[2:5, :]</span>

<span class="sd">        * Vectorized (non-orthogonal) indexing along x- and y-axes:</span>

<span class="sd">            dataset.ndloc[[1, 2, 3], [0, 2, 3]]</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">ndloc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
</pre></div>
</div>
<!-- Previous / next buttons -->
<div class="prev-next-area">
</div>
</main>
</div>
</div>
<script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
<div class="container">
<div class="footer-item">
<p class="copyright">
    Â© Copyright 2021 HoloViz developers.<br/>
</p>
</div>
<div class="footer-item">
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.1.<br/>
</p>
</div>
</div>
</footer>
</body>
</html>